/* This code has been automatically generated by running: 
 * `hcc -transpile all.HC`
 * please check for errors! */

#include <arpa/inet.h>
#include <dirent.h>
#include <fcntl.h>
#include <math.h>
#include <netdb.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#define TRUE 1
#define FALSE 0
#define CSV_EOF 0
#define CSV_ROW 1
#define CSV_FIELD 2
#define CDATE_YEAR_DAYS_INT 36524225
#define CDATE_BASE_DAY_OF_WEEK 0
#define HT_LOAD 0.6
#define HT_DELETED 9223372036854775807
#define STR_LEN 256
#define PRTF_PAD_ZERO 1
#define PRTF_LEFT_JUSTIFY 2
#define PRTF_TRUNCATE 4
#define PRTF_DOLLAR 16
#define PRTF_SLASH 32
#define PRTF_DECIMAL 256
#define PRTF_NEG 512
#define CH_SHIFT_SPACE 31
#define CH_SPACE 32
#define RM_RECURSE 1
#define RM_VERBOSE 2
#define RM_FORCE 4
#define FZF_CASE_SMART 0
#define FZF_CASE_RESPECT 2
#define JSON_STRNUM_FLAG 1
#define JSON_STRING 0
#define JSON_FLOAT 1
#define JSON_INT 2
#define JSON_STRNUM 3
#define JSON_ARRAY 4
#define JSON_OBJECT 5
#define JSON_BOOL 6
#define JSON_NULL 7
#define JSON_OK 0
#define JSON_INVALID_STRING_NOT_TERMINATED 4
#define JSON_INVALID_NUMBER 5
#define JSON_INVALID_JSON_TYPE_CHAR 8
#define JSON_CANNOT_ADVANCE 11
#define JSON_CANNOT_START_PARSE 12
#define JSON_INVALID_KEY_TERMINATOR_CHARACTER 13
#define JSON_INVALID_ARRAY_CHARACTER 15
#define JSON_INVALID_ESCAPE_CHARACTER 16
#define JSON_EOF 17
#define TIMESTAMP_FMT "%d-%02d-%02d %02d:%02d:%02d"
#define __RB_RED__ 0
#define __RB_BLACK__ 1
#define INTERNAL_RM_DIRECORY 6
#define FZF_SCORE_MATCH 16
#define FZF_SCORE_GAP_START -3
#define FZF_SCORE_GAP_EXTENTION -1
#define FZF_BONUS_BOUNDARY 8
#define FZF_BONUS_NON_WORD 8
#define FZF_BONUS_CAMEL_123 7
#define FZF_BONUS_CONSECUTIVE 4
#define FZF_BONUS_FIRST_CHAR_MULTIPLIER 2
#define FZF_CHAR_NON_WORD 0
#define FZF_CHAR_LOWER 1
#define FZF_CHAR_UPPER 2
#define FZF_CHAR_NUMBER 4
#define JSON_PARSER_STRING 0
#define JSON_PARSER_NUMERIC 1
#define JSON_PARSER_ARRAY 2
#define JSON_PARSER_OBJECT 3
#define JSON_PARSER_BOOL 4
#define JSON_PARSER_NULL 5
#define JSON_SEL_INVALD 0
#define JSON_SEL_OBJ 1
#define JSON_SEL_ARRAY 2
#define JSON_SEL_TYPECHECK 3
#define JSON_SEL_MAX_BUF 256
#define IPPROTO_TCP 6

typedef struct List {
    void *value;
    struct List *next;
    struct List *prev;
} List;

typedef struct CsvParser {
    unsigned char *csv;
    unsigned long len;
    unsigned long off;
    unsigned long row_off;
    unsigned long nrows;
    unsigned long nfields;
    long state;
} CsvParser;

typedef struct CsvSlice {
    unsigned long idx;
} CsvSlice;

typedef struct CDate {
    unsigned int time;
    int date;
} CDate;

typedef struct CDateStruct {
    unsigned long sec10000;
    unsigned long sec100;
    unsigned long sec;
    unsigned long min;
    unsigned long hour;
    unsigned long day_of_week;
    unsigned long day_of_mon;
    unsigned long mon;
    int year;
    long zone_diff;
} CDateStruct;

typedef struct IntVec {
    long size;
    long *entries;
} IntVec;

typedef struct PtrVec {
} PtrVec;

typedef struct FloatVec {
} FloatVec;

typedef struct IntMapNode {
    long key;
} IntMapNode;

typedef struct StrMapNode {
    long key_len;
} StrMapNode;

typedef struct IntMap {
    unsigned long capacity;
    unsigned long mask;
    IntVec *indexes;
    unsigned long threashold;
    void (*_free_value)(void *value);
} IntMap;

typedef struct StrMap {
    void (*_free_key)(void *_key);
} StrMap;

typedef struct ThreadWorker {
    pthread_t *th;
    int id;
} ThreadWorker;

typedef struct ThreadSemaphore {
    pthread_cond_t cond;
    pthread_mutex_t lk;
    int val;
} ThreadSemaphore;

typedef struct ThreadWorkerJob {
    void *(*callback)(void *priv_data, void *argv);
    void *argv;
} ThreadWorkerJob;

typedef struct ThreadPool {
    unsigned long worker_count;
    unsigned long alive_threads;
    unsigned long active_threads;
    char run;
    pthread_cond_t has_work;
    pthread_cond_t no_work;
    pthread_mutex_t lock;
    pthread_mutex_t qlock;
    ThreadSemaphore *sem;
    ThreadWorker *workers;
    List *jobs;
    void *priv_data;
} ThreadPool;

typedef struct cDIR {
} cDIR;

typedef struct Dirent {
    unsigned long ino;
    unsigned long seekoff;
    unsigned short reclen;
    unsigned char type;
    char name[DIR_MAXPATHLEN];
} Dirent;

typedef struct cStat {
    unsigned long st_dev;
    unsigned long st_ino;
    unsigned long st_nlink;
    unsigned int st_mode;
    unsigned int st_uid;
    unsigned int st_gid;
    int __pad0;
    unsigned long st_rdev;
    long st_size;
    long st_blksize;
    long st_blocks;
    cTimespec st_atim;
    cTimespec st_mtim;
    cTimespec st_ctim;
    long __glibc_reserved[24];
} cStat;

typedef struct FzFPosition {
    long *data;
    long cap;
    long score;
} FzFPosition;

typedef struct JsonState {
    unsigned char ch;
    long offset;
    long error;
} JsonState;

typedef struct Json {
    union {
        struct Json *array;
        struct Json *object;
        unsigned char *str;
        char boolean;
        unsigned char *strnum;
        double f64;
        long i64;
    };
} Json;

typedef struct RBNode {
    long color;
    struct RBNode *left;
    struct RBNode *right;
    struct RBNode *parent;
} RBNode;

typedef struct RBTree {
    RBNode *root;
    void (*free_key)(void *_unknow);
    void (*free_value)(void *_unknow);
    long (*key_cmp)(void *_unknow, void *_unknow);
} RBTree;

typedef struct RBIter {
    long sp;
    RBNode **stack;
    RBNode *cur;
    RBNode *node;
} RBIter;

typedef struct IntSet {
    RBTree *tree;
} IntSet;

typedef struct IntSetEntry {
} IntSetEntry;

typedef struct IntSetIter {
    RBIter *it;
    IntSetEntry *entry;
} IntSetIter;

typedef struct FzFI16 {
    char allocated;
} FzFI16;

typedef struct FzFI32 {
} FzFI32;

typedef struct FzFResult {
    long start;
    long end;
} FzFResult;

typedef struct FzFSlab {
    FzFI16 i16;
    FzFI32 i32;
} FzFSlab;

typedef struct FzFSlabConfig {
    long size_16;
    long size_32;
} FzFSlabConfig;

typedef struct FzFString {
} FzFString;

typedef struct FzFTerm {
    FzFResult *(*fn)(FzFResult *res, char case_sensitive, FzFString *text, FzFString *pattern, FzFPosition *pos, FzFSlab *slab);
    char inv;
    unsigned char *ptr;
    void *text;
    char case_sensitive;
} FzFTerm;

typedef struct FzFTermSet {
} FzFTermSet;

typedef struct FzFPattern {
    char only_inv;
} FzFPattern;

typedef struct FzFStrSlice {
} FzFStrSlice;

typedef struct JsonParser {
    unsigned char *buffer;
    long buflen;
    struct Json *J;
    int flags;
} JsonParser;

typedef struct JsonStringBuilder {
    unsigned char *buf;
} JsonStringBuilder;


void
Exit(long exit_code)
{
    long retval;
    __asm__ volatile (
        "call exit\n\t"
        : "=a"(retval)
        : "D"()
    );
}

long
Write(long fd, unsigned char *buf, long len)
{
    long retval;
    __asm__ volatile (
        "movq SYS_CALL_WRITE, %%rax\n\t"
        "syscall\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(fd), "S"(buf), "d"(len)
    );
    return retval;
}

long
System(unsigned char *command)
{
    long retval;
    __asm__ volatile (
        "call system\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(command)
    );
    return retval;
}

unsigned long
Abs(long num)
{
    unsigned long retval;
    __asm__ volatile (
        "mov %%rdi, %%rax\n\t"
        "neg %%rax\n\t"
        "cmovl %%rdi, %%rax\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(num)
    );
    return retval;
}

unsigned long
Gcd(long a, long b)
{
    unsigned long retval;
    __asm__ volatile (
        "test %%rsi, %%rsi\n\t"
        "%%rdi, %%rax\n\t"
        "jne ._gcd_2\n\t"
        "jmp ._gcd_1\n\t"
        "._gcd_3:\n\t"
        "mov %%rsi, %%rdx\n\t"
        "._gcd_2:\n\t"
        "cqto\n\t"
        "idiv %%rsi\n\t"
        "test %%rdx, %%rdx\n\t"
        "mov %%rsi, %%rax\n\t"
        "jne ._gcd_3\n\t"
        "movq %%rsi, %%rax\n\t"
        "ret\n\t"
        "._gcd_1:\n\t"
        "mov %%rdi, %%rax\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(a), "S"(b)
    );
    return retval;
}

void *
MAlloc(unsigned long size)
{
    void *retval;
    __asm__ volatile (
        "sub $16, %%rsp\n\t"
        "mov %%rdi, -8(%%rbp)\n\t"
        "add $8, %%rdi\n\t"
        "call malloc\n\t"
        "mov -8(%%rbp), %%rcx\n\t"
        "mov %%rcx, (%%rax)\n\t"
        "add $8, %%rax\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(size)
    );
    return retval;
}

void
Free(void *ptr)
{
    long retval;
    __asm__ volatile (
        "test %%rdi, %%rdi\n\t"
        "jz ._free_1\n\t"
        "sub $8, %%rdi\n\t"
        "call free\n\t"
        "._free_1:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(ptr)
    );
}

void *
ReAlloc(void *ptr, unsigned long new_size)
{
    void *retval;
    __asm__ volatile (
        "sub $16, %%rsp\n\t"
        "test %%rdi, %%rdi\n\t"
        "jz ._realloc_1\n\t"
        "mov %%rdi, -8(%%rbp)\n\t"
        "mov %%rsi, %%rdi\n\t"
        "call MAlloc\n\t"
        "mov %%rax, -16(%%rbp)\n\t"
        "mov -8(%%rbp), %%rdi\n\t"
        "call MSize\n\t"
        "mov %%rax, %%rdx\n\t"
        "mov -8(%%rbp), %%rsi\n\t"
        "mov -16(%%rbp), %%rdi\n\t"
        "call MemCpy\n\t"
        "mov -8(%%rbp), %%rdi\n\t"
        "call Free\n\t"
        "mov -16(%%rbp), %%rax\n\t"
        "jmp ._realloc_2\n\t"
        "._realloc_1:\n\t"
        "mov %%rsi, %%rdi\n\t"
        "call MAlloc\n\t"
        "._realloc_2:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(ptr), "S"(new_size)
    );
    return retval;
}

void *
CAlloc(unsigned long new_size)
{
    void *retval;
    __asm__ volatile (
        "sub $16, %%rsp\n\t"
        "mov %%rdi, -8(%%rbp)\n\t"
        "call MAlloc\n\t"
        "mov %%rax, -16(%%rbp)\n\t"
        "mov -8(%%rbp), %%rdx\n\t"
        "mov $0, %%rsi\n\t"
        "mov -16(%%rbp), %%rdi\n\t"
        "call MemSet\n\t"
        "mov -16(%%rbp), %%rax\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(new_size)
    );
    return retval;
}

unsigned long
MSize(void *ptr)
{
    unsigned long retval;
    __asm__ volatile (
        "test %%rdi, %%rdi\n\t"
        "jz ._msize_2\n\t"
        "sub $8, %%rdi\n\t"
        "mov (%%rdi), %%rax\n\t"
        "._msize_1:\n\t"
        "leave\n\t"
        "ret\n\t"
        "._msize_2:\n\t"
        "movq $0, %%rax\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(ptr)
    );
    return retval;
}

void *
MemCpy(void *dst, void *src, unsigned long len)
{
    void *retval;
    __asm__ volatile (
        "movq %%rdx, %%rcx\n\t"
        "cld\n\t"
        "rep movsb\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(dst), "S"(src), "d"(len)
    );
    return retval;
}

void *
MemSet(void *dst, int ch, unsigned long len)
{
    void *retval;
    __asm__ volatile (
        "movq %%rdx, %%rcx\n\t"
        "movb %%sil, %%al\n\t"
        "cld\n\t"
        "rep stosb\n\t"
        "movq %%rax, %%rdi\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(dst), "S"(ch), "d"(len)
    );
    return retval;
}

unsigned long
StrLen(unsigned char *buf)
{
    unsigned long retval;
    __asm__ volatile (
        "movq %%rdi, %%rsi\n\t"
        "xor %%rax, %%rax\n\t"
        "movq $-1, %%rcx\n\t"
        "repnz scasb\n\t"
        "not %%rcx\n\t"
        "dec %%rcx\n\t"
        "movq %%rcx, %%rax\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(buf)
    );
    return retval;
}

long
StrNCmp(unsigned char *s1, unsigned char *s2, long len)
{
    long retval;
    __asm__ volatile (
        "movq %%rdx, %%rcx\n\t"
        "test %%rcx, %%rcx\n\t"
        "jz ._strncmp_2\n\t"
        "repe cmpsb\n\t"
        "je ._strncmp_1\n\t"
        "movzbq -1(%%rdi), %%rax\n\t"
        "movzbq -1(%%rsi), %%rdx\n\t"
        "subq %%rdx, %%rax\n\t"
        "leave\n\t"
        "ret\n\t"
        "._strncmp_1:\n\t"
        "xorq %%rax, %%rax\n\t"
        "._strncmp_2:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(s1), "S"(s2), "d"(len)
    );
    return retval;
}

long
StrNICmp(unsigned char *s1, unsigned char *s2, long len)
{
    long retval;
    __asm__ volatile (
        "movq %%rdx, %%rcx\n\t"
        "._strnicmp_3:\n\t"
        "test %%rcx, %%rcx\n\t"
        "jz ._strnicmp_2\n\t"
        "decq %%rcx\n\t"
        "lodsb\n\t"
        "test %%al, %%al\n\t"
        "jz ._strnicmp_6\n\t"
        "cmp $97, %%al\n\t"
        "jb ._strnicmp_22\n\t"
        "cmp $122, %%al\n\t"
        "ja ._strnicmp_22\n\t"
        "sub $32, %%al\n\t"
        "._strnicmp_22:\n\t"
        "mov (%%rdi), %%bl\n\t"
        "incq %%rdi\n\t"
        "test %%bl, %%bl\n\t"
        "jz ._strnicmp_6\n\t"
        "cmp $97, %%bl\n\t"
        "jb ._strnicmp_23\n\t"
        "cmp $122, %%bl\n\t"
        "ja ._strnicmp_23\n\t"
        "sub $32, %%bl\n\t"
        "._strnicmp_23:\n\t"
        "cmp %%bl, %%al\n\t"
        "je ._strnicmp_3\n\t"
        "._strnicmp_6:\n\t"
        "subq %%rdi, %%rsi\n\t"
        "movq %%rsi, %%rax\n\t"
        "leave\n\t"
        "ret\n\t"
        "._strnicmp_2:\n\t"
        "xorq %%rax, %%rax\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(s1), "S"(s2), "d"(len)
    );
    return retval;
}

long
StrCmp(unsigned char *s1, unsigned char *s2)
{
    long retval;
    __asm__ volatile (
        "._strcmp_2:\n\t"
        "lodsb\n\t"
        "scasb\n\t"
        "jne ._strcmp_1\n\t"
        "test %%al, %%al\n\t"
        "jnz ._strcmp_2\n\t"
        "xor %%rax, %%rax\n\t"
        "jmp ._strcmp_3\n\t"
        "._strcmp_1:\n\t"
        "sub $1, %%rdi\n\t"
        "movzx %%al, %%rax\n\t"
        "movzbq (%%rdi), %%rdx\n\t"
        "sub %%rdx, %%rax\n\t"
        "._strcmp_3:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(s1), "S"(s2)
    );
    return retval;
}

void
StrCpy(unsigned char *dst, unsigned char *src)
{
    long retval;
    __asm__ volatile (
        "test %%rdi, %%rdi\n\t"
        "jz ._strcpy_15\n\t"
        "test %%rsi, %%rsi\n\t"
        "jnz ._strcpy_5\n\t"
        "xor %%rax, %%rax\n\t"
        "jmp ._strcpy_10\n\t"
        "._strcpy_5:\n\t"
        "lodsb\n\t"
        "._strcpy_10:\n\t"
        "stosb\n\t"
        "test %%al, %%al\n\t"
        "jnz ._strcpy_5\n\t"
        "._strcpy_15:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(dst), "S"(src)
    );
}

unsigned char
ToLower(unsigned char ch)
{
    unsigned char retval;
    __asm__ volatile (
        "movq %%rdi, %%rax\n\t"
        "cmp $0X41, %%al\n\t"
        "jb ._tolower_1\n\t"
        "cmp $0X5A, %%al\n\t"
        "ja ._tolower_1\n\t"
        "add $32, %%al\n\t"
        "._tolower_1:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(ch)
    );
    return retval;
}

unsigned char
ToUpper(unsigned char ch)
{
    unsigned char retval;
    __asm__ volatile (
        "movq %%rdi, %%rax\n\t"
        "cmp $0X61, %%al\n\t"
        "jb ._toupper_1\n\t"
        "cmp $0X7A, %%al\n\t"
        "ja ._toupper_1\n\t"
        "sub $32, %%al\n\t"
        "._toupper_1:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(ch)
    );
    return retval;
}

char
IsSpace(unsigned char ch)
{
    char retval;
    __asm__ volatile (
        "movq %%rdi, %%rax\n\t"
        "cmp $0X20, %%al\n\t"
        "je ._isspace_5\n\t"
        "cmp $0X9, %%al\n\t"
        "je ._isspace_5\n\t"
        "cmp $0XA, %%al\n\t"
        "je ._isspace_5\n\t"
        "cmp $0XB, %%al\n\t"
        "je ._isspace_5\n\t"
        "cmp $0XC, %%al\n\t"
        "je ._isspace_5\n\t"
        "cmp $0XD, %%al\n\t"
        "je ._isspace_5\n\t"
        "jmp ._isspace_10\n\t"
        "._isspace_5:\n\t"
        "movq $1, %%rax\n\t"
        "jmp ._isspace_15\n\t"
        "._isspace_10:\n\t"
        "movq $0, %%rax\n\t"
        "._isspace_15:\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(ch)
    );
    return retval;
}

unsigned long
StrHash(unsigned char *str)
{
    unsigned long retval;
    __asm__ volatile (
        "movzbl (%%rdi), %%ecx\n\t"
        "leaq 1(%%rdi), %%rsi\n\t"
        "movsbl 1(%%rdi), %%eax\n\t"
        "test %%al, %%al\n\t"
        "je ._strhash_10\n\t"
        "._strhash_5:\n\t"
        "movq %%rcx, %%rdx\n\t"
        "salq $5, %%rdx\n\t"
        "sub %%rcx, %%rdx\n\t"
        "movzbl %%al, %%eax\n\t"
        "movq %%rax, %%rcx\n\t"
        "add %%rdx, %%rcx\n\t"
        "add $1, %%rsi\n\t"
        "movzbl (%%rsi), %%eax\n\t"
        "test %%al, %%al\n\t"
        "jne ._strhash_5\n\t"
        "._strhash_10:\n\t"
        "mov %%rcx, %%rax\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(str)
    );
    return retval;
}

long
Atoi(unsigned char *str)
{
    long retval;
    __asm__ volatile (
        "mov $0, %%rax\n\t"
        "xor %%r8, %%r8\n\t"
        "cmpb $0X2D, (%%rdi)\n\t"
        "jne ._atoi_1\n\t"
        "add $1, %%rdi\n\t"
        "mov $1, %%r8\n\t"
        "._atoi_1:\n\t"
        "cmpb $48, (%%rdi)\n\t"
        "jl ._atoi_2\n\t"
        "cmpb $0X39, (%%rdi)\n\t"
        "jg ._atoi_2\n\t"
        "movb (%%rdi), %%bl\n\t"
        "subb $0X30, %%bl\n\t"
        "movzbq %%bl, %%rbx\n\t"
        "imul $10, %%rax\n\t"
        "add %%rbx, %%rax\n\t"
        "add $1, %%rdi\n\t"
        "jmp ._atoi_1\n\t"
        "._atoi_2:\n\t"
        "test %%r8, %%r8\n\t"
        "jz ._atoi_3\n\t"
        "neg %%rax\n\t"
        "._atoi_3:\n\t"
        "leave\n\t"
        "ret\n\t"
        : "=a"(retval)
        : "D"(str)
    );
    return retval;
}

double
pow(double a, long b)
{
    if (b == 0) {
        return 1;
    }
    double result = 1;
    if (b < 0) {
        a = 1 / a;
        b = -b;
    }
    while (b > 0) {
        if (b & 2 != 1) {
            result = result * a;
        }
        a = a * a;
        b = b / 2;
    }
    return result;
}

unsigned long
modU64(unsigned long *k, unsigned long m)
{
    return **k % m;
}

unsigned long
nowMilliseconds(void)
{
    timeval tm;
    gettimeofday(&tm, NULL);
    return tm.tv_sec * 1000 + tm.tv_usec / 1000;
}

void
nowDateTimeStruct(CDateStruct *_ds)
{
    timeval _tv;
    tm *ptm;
    unsigned long milliseconds;
    unsigned long seconds;
    gettimeofday(&_tv, NULL);
    milliseconds = _tv.tv_sec * 1000 + _tv.tv_usec / 1000;
    seconds = milliseconds / 1000;
    ptm = localtime(&seconds);
    *_ds->sec10000 = _tv.tv_usec / 100;
    *_ds->sec100 = _tv.tv_usec / 10000;
    *_ds->sec = (unsigned long)*ptm->tm_sec;
    *_ds->min = (unsigned long)*ptm->tm_min;
    *_ds->hour = (unsigned long)*ptm->tm_hour;
    *_ds->year = (unsigned long)*ptm->tm_year;
    *_ds->mon = (unsigned long)*ptm->tm_mon;
    *_ds->mon = *_ds->mon + 1;
    *_ds->day_of_week = (unsigned long)*ptm->tm_wday;
    *_ds->day_of_mon = (unsigned long)*ptm->tm_mday;
    *_ds->year = *_ds->year + 1900;
}

long
yearStartDate(long year)
{
    long y1 = year - 1;
    long yd4000 = y1 / 4000;
    long yd400 = y1 / 400;
    long yd100 = y1 / 100;
    long yd4 = y1 / 4;
    return year * 365 + yd4 - yd100 + yd400 - yd4000;
}

long
dayOfWeek(long i)
{
    i = i + CDATE_BASE_DAY_OF_WEEK;
    if (i >= 0) {
        return i % 7;
    } else return 6 - 6 - i % 7;
}

void
date2Struct(CDateStruct *_ds, CDate cdt)
{
    long i;
    long k;
    long date = cdt.date;
    *_ds->day_of_week = dayOfWeek(date);
    *_ds->year = date + 1 * 100000 / CDATE_YEAR_DAYS_INT;
    i = yearStartDate(*_ds->year);
    while (i > date) {
        --*_ds->year;
        i = yearStartDate(*_ds->year);
    }
    date = date - i;
    if (yearStartDate(*_ds->year + 1) - i == 365) {
        k = 0;
        while (date >= *(mon_start_days1[k + 1]) && k < 11) {
            ++k;
        }
        date = date - *(mon_start_days1[k]);
    } else {
        k = 0;
        while (date >= *(mon_start_days2[k + 1]) && k < 11) {
            ++k;
        }
        date = date - *(mon_start_days2[k]);
    }
    *_ds->mon = k + 1;
    *_ds->day_of_mon = date + 1;
    k = 625 * 15 * 15 * 3 * cdt.time >> 21 + 1;
    *_ds->sec10000 = modU64(&k, 100);
    *_ds->sec100 = modU64(&k, 100);
    *_ds->sec = modU64(&k, 60);
    *_ds->min = modU64(&k, 60);
    *_ds->hour = k;
}

CDate
struct2Date(CDateStruct *_ds)
{
    CDate cdt;
    long i1;
    long i2;
    i1 = yearStartDate(*_ds->year);
    i2 = yearStartDate(*_ds->year + 1);
    if (i2 - i1 == 365) {
        i1 = i1 + *(mon_start_days1[*_ds->mon - 1]);
    } else {
        i1 = i1 + *(mon_start_days2[*_ds->mon - 1]);
    }
    cdt.date = i1 + *_ds->day_of_mon - 1;
    cdt.time = *_ds->sec10000 + 100 * *_ds->sec100 + 100 * *_ds->sec + 60 * *_ds->min + 60 * *_ds->hour << 21 / 15 * 15 * 3 * 625;
    return cdt;
}

int
firstDayOfMon(long i)
{
    CDateStruct ds;
    CDate cdt = 0;
    cdt.date = i;
    date2Struct(&ds, cdt);
    cdt = struct2Date(&ds);
    return cdt.date;
}

long
lastDayOfMon(long i)
{
    CDateStruct ds;
    CDate cdt = 0;
    cdt.date = i;
    date2Struct(&ds, cdt);
    ++ds.mon;
    if (ds.mon == 13) {
        ds.mon = 0;
        ++ds.year;
    }
    ds.day_of_mon = 1;
    cdt = struct2Date(&ds);
    return cdt.date - 1;
}

int
firstDayOfYear(long i)
{
    CDateStruct ds;
    CDate cdt = 0;
    cdt.date = i;
    date2Struct(&ds, cdt);
    ds.day_of_mon = 1;
    ds.mon = 1;
    cdt = struct2Date(&ds);
    return cdt.date;
}

long
lastDayOfYear(long i)
{
    CDateStruct ds;
    CDate cdt = 0;
    cdt.date = i;
    date2Struct(&ds, cdt);
    ds.day_of_mon = 1;
    ds.mon = 1;
    ++ds.year;
    cdt = struct2Date(&ds);
    return cdt.date - 1;
}

CDate
now(void)
{
    CDateStruct ds;
    CDate cdt = 0;
    nowDateTimeStruct(&ds);
    cdt = struct2Date(&ds);
    return cdt;
}

unsigned char *
fileRead(unsigned char *path, long *_size)
{
    if (!path) {
        return NULL;
    }
    int fd;
    long len;
    long rbytes;
    long size;
    unsigned char *s;
    if (fd = open(path, O_RDONLY, 438) == -1) {
        return NULL;
    }
    if (len = lseek(fd, 0, SEEK_END) == -1) {
        close(fd);
        return NULL;
    }
    lseek(fd, 0, SEEK_SET);
    s = malloc(len + 100);
    size = 0;
    while (rbytes = read(fd, s + size, len) != 0) {
        size = size + rbytes;
    }
    if (size != len) {
        close(fd);
        free(s);
        if (_size) {
            **_size = 0;
        }
        return NULL;
    }
    if (_size) {
        **_size = len;
    }
    *(s[len]) = '\0';
    close(fd);
    return s;
}

char
fileWrite(unsigned char *filename, unsigned char *buf, long size, long flags)
{
    long towrite = size;
    long nwritten = 0;
    int fd;
    int perms = 420;
    if (fd = open(filename, flags, perms) == -1) {
        return FALSE;
    }
    while (towrite > 0) {
        nwritten = write(fd, buf, towrite);
        if (nwritten < 0) {
            close(fd);
            return FALSE;
        }
        buf = buf + nwritten;
        towrite = towrite - nwritten;
    }
    close(fd);
    return TRUE;
}

int
cd(unsigned char *path)
{
    return chdir(path);
}

unsigned char *
strNCpy(unsigned char *buf, long len)
{
    unsigned char *str = malloc(sizeof(unsigned char) * len + 1);
    if (len == 0) {
        return str;
    }
    memcpy(str, buf, len);
    *(str[len]) = '\0';
    return str;
}

unsigned char *
strNew(unsigned char *buf)
{
    unsigned char *res;
    long size;
    if (buf) {
        size = strlen(buf) + 1;
        res = malloc(size);
        memcpy(res, buf, size);
        *(res[size - 1]) = '\0';
    } else {
        res = malloc(1);
        **res = 0;
    }
    return res;
}

unsigned char *
fileExtDot(unsigned char *src)
{
    long ch;
    while (ch = **++src) {
        if (ch == '.' && !=**src'/' && !=**src'.') {
            return src - 1;
        }
    }
    return NULL;
}

unsigned char *
fileExtRem(unsigned char *src, unsigned char *dst)
{
    unsigned char *ptr;
    if (ptr = fileExtDot(src)) {
        if (dst) {
            strcpy(dst, ptr + 1);
        }
        **ptr = 0;
    } else if (dst) {
        **dst = 0;
    }
    return dst;
}

char
isDotZ(unsigned char *filename)
{
    long i = strlen(filename);
    if (strOcc(filename, '.') > 1 && *(filename[i - 1]) == 'Z' && *(filename[i - 2]) == '.') {
        return TRUE;
    } else return FALSE;
}

char
isDotC(unsigned char *filename)
{
    long i = strlen(filename);
    if (strOcc(filename, '.') > 1 && *(filename[i - 1]) == 'C' && *(filename[i - 2]) == '.') {
        return TRUE;
    } else return FALSE;
}

void
sPutChar(unsigned char **_dst, unsigned char ch, unsigned char **_buf)
{
    long i;
    unsigned char *dst = **_dst;
    unsigned char *buf;
    if (_buf) {
        buf = **_buf;
        i = dst - buf;
        if (i >= MSize(buf)) {
            buf = malloc(i << 1 + 1);
            memcpy(buf, **_buf, i);
            free(**_buf);
            dst = buf + i;
            **_buf = buf;
        }
    }
    **++dst = ch;
    **dst = '\0';
    **_dst = dst;
}

void
outStr(unsigned char *instr, unsigned char **_buf, unsigned char **_dst, long len, long flags)
{
    long i;
    long j;
    long size;
    long dst_len;
    unsigned char *buf;
    unsigned char *dst;
    if (!instr) {
        i = 0;
    } else i = strlen(instr);
    dst = **_dst;
    buf = **_buf;
    dst_len = dst - buf;
    size = MSize(buf);
    if (i >= size - dst_len) {
        buf = realloc(buf, size * 10 + i * sizeof(unsigned char));
        **_buf = buf;
        **_dst = buf + dst_len;
        dst = **_dst;
    }
    if (flags & PRTF_TRUNCATE && i > len) {
        i = len;
    }
    if (flags & PRTF_LEFT_JUSTIFY) {
        for (j = 0; j < i; ++j) {
            sPutChar(_dst, **++instr, _buf);
        }
        for (j = 0; j < len - i; ++j) {
            sPutChar(_dst, CH_SPACE, _buf);
        }
    } else {
        for (j = 0; j < len - i; ++j) {
            sPutChar(&dst, CH_SPACE, _buf);
        }
        for (j = len - i; j < len; ++j) {
            sPutChar(_dst, **++instr, _buf);
        }
    }
}

long
strOcc(unsigned char *src, long ch)
{
    long i = 0;
    if (!src) {
        return 0;
    }
    while (**src) {
        if (**++src == ch) {
            ++i;
        }
    }
    return i;
}

unsigned char *
strFirstOcc(unsigned char *src, unsigned char *marker)
{
    long ch;
    while (ch = **++src && !strOcc(marker, ch))
        ;
    if (ch) {
        return src - 1;
    } else return NULL;
}

unsigned char *
strFirstRem(unsigned char *src, unsigned char *marker, unsigned char *dst)
{
    long ch;
    unsigned char *ptr = src;
    unsigned char *res = dst;
    if (dst) {
        while (ch = **++ptr && !strOcc(marker, ch)) {
            **++dst = ch;
        }
        **dst = 0;
    } else while (ch = **++ptr && !strOcc(marker, ch))
        ;
    if (ch) {
        strcpy(src, ptr);
    } else **src = 0;
    return res;
}

unsigned char *
strLastOcc(unsigned char *src, unsigned char *marker)
{
    long ch;
    unsigned char *res = NULL;
    while (ch = **++src) {
        if (strOcc(marker, ch)) {
            res = src - 1;
        }
    }
    return res;
}

unsigned char *
strLastRem(unsigned char *src, unsigned char *marker, unsigned char *dst)
{
    unsigned char *ptr;
    if (ptr = strLastOcc(src, marker) != NULL) {
        if (dst) {
            strcpy(dst, ptr + 1);
        }
        **ptr = 0;
    } else {
        if (dst) {
            strcpy(dst, src);
        }
        **src = 0;
    }
    return dst;
}

unsigned char *
strTrimStart(unsigned char *str, long str_len, long *_new_len)
{
    long new_len;
    long len;
    long j;
    len = strlen(str);
    j = 0;
    while (TRUE) {
        if (isspace(*(str[j]))) {
            pre ++j;
        } else {
            break;
        }
    }
    new_len = len - j;
    if (_new_len) {
        **_new_len = new_len;
    }
    if (new_len == len) {
        return str;
    }
    memmove(str, str + j, new_len);
    *(str[new_len]) = '\0';
    return str;
}

unsigned char *
strTrimEnd(unsigned char *str, long str_len, long *_new_len)
{
    long new_len;
    long len;
    long i;
    if (str_len == -1) {
        len = strlen(str);
    } else {
        len = str_len;
    }
    i = len - 1;
    while (TRUE) {
        if (isspace(*(str[i]))) {
            pre --i;
        } else {
            break;
        }
    }
    ++i;
    new_len = i;
    if (_new_len) {
        **_new_len = new_len;
    }
    if (new_len == len) {
        return str;
    }
    memmove(str, str, new_len);
    *(str[new_len]) = '\0';
    return str;
}

void
strReverse(unsigned char *buf, long length)
{
    long start = 0;
    long end = length - 1;
    while (start < end) {
        unsigned char temp = *(buf[start]);
        *(buf[start]) = *(buf[end]);
        *(buf[end]) = temp;
        ++start;
        --end;
    }
}

long
i64ToStr(unsigned char *buf, long num, char *_is_neg, long _len)
{
    long i = 0;
    if (num == 0) {
        *(buf[++i]) = '0';
        *(buf[i]) = '\0';
        return 1;
    }
    if (_is_neg) {
        **_is_neg = FALSE;
    }
    if (num < 0) {
        if (_is_neg) {
            **_is_neg = TRUE;
        }
        num = -num;
    }
    while (num != 0 && _len != 0) {
        long rem = num % 10;
        if (rem > 9) {
            *(buf[++i]) = rem - 10 + 'a';
        } else {
            *(buf[++i]) = rem + '0';
        }
        num = num / 10;
        --_len;
    }
    *(buf[i]) = '\0';
    return i;
}

unsigned long
u64ToStr(unsigned char *dst, unsigned long num, long len)
{
    long i = 0;
    if (num == 0) {
        *(dst[++i]) = '0';
        *(dst[i]) = '\0';
        return 1;
    }
    while (num != 0 && len != 0) {
        long rem = num % 10;
        if (rem > 9) {
            *(dst[++i]) = rem - 10 + 'a';
        } else {
            *(dst[++i]) = rem + '0';
        }
        num = num / 10;
        --len;
    }
    *(dst[i]) = '\0';
    return i;
}

long
strIntToHex(unsigned char *dst, long num)
{
    unsigned char *hex_str = "0123456789ABCDEF";
    long i = sizeof(unsigned long) * 2 + 3;
    long len = 2;
    *(dst[i - 1]) = '\0';
    while (i >= 2) {
        ++len;
        *(dst[i]) = *(hex_str[num & 15]);
        num = num >> 4;
        --i;
    }
    *(dst[i]) = 'x';
    *(dst[i - 1]) = '0';
    return len;
}

unsigned char *
mPrintQ(unsigned char *ptr, long flags)
{
    unsigned char **_buf;
    unsigned char *buf;
    unsigned char **_dst;
    unsigned char *dst;
    unsigned char buf2[8];
    unsigned char *ptr2;
    long ch;
    buf = malloc(STR_LEN);
    _buf = &buf;
    dst = buf;
    _dst = &dst;
    if (ptr) {
        while (ch = **++ptr) {
            if (ch == 9252) {
                if (flags & PRTF_DOLLAR) {
                    sPutChar(_dst, '\\', _buf);
                    sPutChar(_dst, 'd', _buf);
                } else {
                    sPutChar(_dst, ch, _buf);
                    sPutChar(_dst, ch, _buf);
                }
            } else {
                switch (ch) {
                    case 37: {
                        sPutChar(_dst, ch, _buf);
                        if (flags & PRTF_SLASH) {
                            sPutChar(_dst, ch, _buf);
                        }
                        break;
                    }

                    case 10: {
                        sPutChar(_dst, '\\', _buf);
                        sPutChar(_dst, 'n', _buf);
                        break;
                    }

                    case 13: {
                        sPutChar(_dst, '\\', _buf);
                        sPutChar(_dst, 'r', _buf);
                        break;
                    }

                    case 9: {
                        sPutChar(_dst, '\\', _buf);
                        sPutChar(_dst, 't', _buf);
                        break;
                    }

                    case 11: {
                        sPutChar(_dst, '\\', _buf);
                        sPutChar(_dst, 'v', _buf);
                        break;
                    }

                    case 12: {
                        sPutChar(_dst, '\\', _buf);
                        sPutChar(_dst, 'f', _buf);
                        break;
                    }

                    case 34:
                    case 92: {
                        sPutChar(_dst, '\\', _buf);
                        sPutChar(_dst, ch, _buf);
                        break;
                    }

                    default: {
                        if (ch >= CH_SHIFT_SPACE && ch != 127) {
                            sPutChar(_dst, ch, _buf);
                        } else {
                            strPrint(buf2, "x%02X", 1, ch);
                            ptr2 = buf2;
                            while (**ptr2) {
                                sPutChar(_dst, **++ptr2, _buf);
                            }
                        }
                    }
                }
            }
        }
    }
    sPutChar(_dst, 0, _buf);
    return buf;
}

unsigned char *
strPrintJoin(unsigned char *_dst, unsigned char *fmt, long argc, long *argv)
{
    if (!fmt) {
        return NULL;
    }
    unsigned long uintarg;
    unsigned long curlen = 0;
    unsigned long memsize;
    double farg;
    long ch;
    long sp = 0;
    long intarg;
    long U8arg;
    long len;
    long flags;
    long tlen;
    long dec_len;
    long aux_fmt_num;
    unsigned char *ptr;
    unsigned char *strarg;
    unsigned char *tmp;
    unsigned char *dst;
    unsigned char buf[256];
    CDate cdt;
    if (_dst == NULL) {
        dst = malloc(STR_LEN);
        memsize = STR_LEN;
    } else {
        memsize = MSize(_dst);
        dst = _dst;
    }
    ptr = dst;
    while (ch = **++fmt) {
        if (ch == '%') {
            flags = 0;
            if (**fmt == '-') {
                flags = flags | PRTF_LEFT_JUSTIFY;
                ++fmt;
            }
            if (**fmt == '0') {
                flags = flags | PRTF_PAD_ZERO;
                ++fmt;
            }
            tlen = 0;
            while ('0' <= **fmt <= '9') {
                tlen = tlen * 10 + **++fmt - '0';
            }
            if (**fmt == '*') {
                ++fmt;
                tlen = (unsigned long)*(argv[++sp]);
            }
            dec_len = -1;
            if (**fmt == '.') {
                ++fmt;
                while ('0' <= **fmt <= '9') {
                    dec_len = dec_len * 10 + **++fmt - '0';
                }
                if (**fmt == '*') {
                    ++fmt;
                    dec_len = *(argv[++sp]);
                    flags = flags | PRTF_TRUNCATE;
                }
                flags = flags | PRTF_DECIMAL;
            }
            aux_fmt_num = 0;
            switch (**++fmt) {
                case '%': {
                    sPutChar(&ptr, '%', &dst);
                    break;
                }

                case 'Q': {
                    strarg = (unsigned char *)*(argv[++sp]);
                    strarg = mPrintQ(strarg, flags);
                    outStr(strarg, &dst, &ptr, tlen, flags);
                    free(strarg);
                    break;
                }

                case 'T': {
                    cdt = (CDate)*(argv[++sp]);
                    strarg = mPrintTime(cdt);
                    outStr(strarg, &dst, &ptr, tlen, flags);
                    free(strarg);
                    break;
                }

                case 'D': {
                    cdt = (CDate)*(argv[++sp]);
                    strarg = mPrintDate(cdt);
                    outStr(strarg, &dst, &ptr, tlen, flags);
                    free(strarg);
                    break;
                }

                case 'f': {
                    printf("Floats not supported\n");
                    exit(1);
                    double n;
                    unsigned long m;
                    long k = 0;
                    long idx = 0;
                    farg = (double)*(argv[++sp]);
                    if (farg < 0) {
                        flags = flags | PRTF_NEG;
                        farg = -farg;
                    }
                    if (dec_len < 0) {
                        dec_len = 0;
                    }
                    idx = dec_len;
                    n = log10(farg);
                    if (n > 17) {
                        n = n - 17;
                        farg = farg * pow(10, -n);
                    } else {
                        n = 0;
                    }
                    m = (unsigned long)round(farg);
                    if (dec_len) {
                        *(buf[++k]) = '.';
                    }
                    while (--idx && sizeof(unsigned char[256]) - 8 < k) {
                        if (n) {
                            --n;
                            *(buf[++k]) = '0';
                        } else {
                            *(buf[++k]) = m % 10 + '0';
                        }
                    }
                    if (dec_len) {
                        *(buf[++k]) = '.';
                    }
                    do {
                        if (n) {
                            --n;
                            *(buf[++k]) = '0';
                        } else {
                            *(buf[++k]) = m % 10 + '0';
                        }
                    } while (sizeof(unsigned char[256]) - 8 < k);
                    if (flags & PRTF_NEG) {
                        sPutChar(&ptr, '-', &dst);
                    }
                    for (long i = k - 1; i >= 0; pre --i) {
                        sPutChar(&ptr, *(buf[i]), &dst);
                    }
                    break;
                }

                case 's': {
                    strarg = (unsigned char *)*(argv[++sp]);
                    outStr(strarg, &dst, &ptr, dec_len, flags);
                    break;
                }

                case 'F': {
                    tmp = (unsigned char *)*(argv[++sp]);
                    strarg = fileRead(tmp, &len);
                    outStr(strarg, &dst, &ptr, dec_len, flags);
                    free(strarg);
                    break;
                }

                case 'c': {
                    uintarg = (unsigned long)*(argv[++sp]);
                    for (long i = 0; i < 8; pre ++i) {
                        *(buf[i]) = uintarg >> i * 8 & 255;
                    }
                    *(buf[8]) = '\0';
                    outStr(buf, &dst, &ptr, tlen, flags);
                    break;
                }

                case 'C': {
                    uintarg = (unsigned long)*(argv[++sp]);
                    for (long i = 0; i < 8; pre ++i) {
                        *(buf[i]) = toupper(uintarg >> i * 8 & 255);
                    }
                    *(buf[8]) = '\0';
                    outStr(buf, &dst, &ptr, tlen, flags);
                    break;
                }

                case 'u':
                case 'd': {
                    uintarg = (unsigned long)*(argv[++sp]);
                    long idx = 0;
                    if (*(*fmt - 1) == 'd') {
                        intarg = (long)uintarg;
                        if (intarg < 0) {
                            idx = 1;
                        }
                        len = i64ToStr(buf, intarg);
                    } else {
                        len = u64ToStr(buf, uintarg);
                    }
                    if (idx) {
                        flags = flags | PRTF_NEG;
                    }
                    if (flags & PRTF_TRUNCATE && len + idx > tlen) {
                        len = tlen - idx;
                    }
                    if (flags & PRTF_PAD_ZERO) {
                        if (flags & PRTF_NEG) {
                            sPutChar(&ptr, '-', &dst);
                        }
                        for (; idx < tlen - len; pre ++idx) {
                            sPutChar(&ptr, '0', &dst);
                        }
                    } else {
                        for (; idx < tlen - len; pre ++idx) {
                            sPutChar(&ptr, CH_SPACE, &dst);
                        }
                        if (flags & PRTF_NEG) {
                            sPutChar(&ptr, '-', &dst);
                        }
                    }
                    for (idx = len - 1; idx >= 0; pre --idx) {
                        sPutChar(&ptr, *(buf[idx]), &dst);
                    }
                    break;
                }

                case 'x': {
                    U8arg = 'a';
                    goto StrPrintJoin_place_hex;
                }

                case 'X': {
                    U8arg = 'A';

StrPrintJoin_place_hex:
                    uintarg = (unsigned long)*(argv[++sp]);
                    len = 0;
                    do {
                        *(buf[len]) = uintarg & 15 + '0';
                        if (*(buf[len]) > '9') {
                            *(buf[len]) = *(buf[len]) + U8arg - 58;
                        }
                        ++len;
                        uintarg = uintarg >> 4;
                    } while (uintarg);
                    if (flags & PRTF_TRUNCATE && len > tlen) {
                        len = tlen;
                    }
                    if (flags & PRTF_PAD_ZERO) {
                        for (long idx = 0; idx < tlen - len; pre ++idx) {
                            sPutChar(&ptr, '0', &dst);
                        }
                    } else {
                        for (long idx = 0; idx < tlen - len; pre ++idx) {
                            sPutChar(&ptr, CH_SPACE, &dst);
                        }
                    }
                    for (long idx = len - 1; idx >= 0; pre --idx) {
                        sPutChar(&ptr, *(buf[idx]), &dst);
                    }
                    break;
                }

                case 'p': {
                    uintarg = (unsigned long)*(argv[++sp]);
                    len = strIntToHex(buf, uintarg);
                    outStr(buf, &dst, &ptr, tlen, flags);
                    break;
                }

                default: {
                    printf("Invalid format char: '%c'\n", **fmt);
                    sPutChar(&ptr, ch, &dst);
                    break;
                }
            }
        } else {
            sPutChar(&ptr, ch, &dst);
        }
    }
    return dst;
}

unsigned char *
strMergeJoin(long argc, unsigned long *argv)
{
    unsigned char *buf = malloc(256);
    unsigned char *dst = buf;
    for (long i = 0; i < argc; pre ++i) {
        outStr((unsigned char *)*(argv[i]), &buf, &dst, 0, 0);
    }
    return buf;
}

unsigned char *
strMerge(...)
{
    return strMergeJoin(argc, argv);
}

unsigned char *
strPrint(unsigned char *dst, unsigned char *fmt, ...)
{
    return strPrintJoin(dst, fmt, argc, argv);
}

unsigned char *
mStrPrint(unsigned char *fmt, ...)
{
    unsigned char *res;
    unsigned char *buf = strPrintJoin(NULL, fmt, argc, argv);
    res = strNew(buf);
    free(buf);
    return res;
}

unsigned char *
mPrintTime(CDate cdt)
{
    CDateStruct ds;
    date2Struct(&ds, cdt);
    return mStrPrint("%02d:%02d:%02d", 3, ds.hour, ds.min, ds.sec);
}

unsigned char *
mPrintDate(CDate cdt)
{
    CDateStruct ds;
    date2Struct(&ds, cdt);
    return mStrPrint("%02d/%02d/%04d", 3, ds.mon, ds.day_of_mon, ds.year);
}

unsigned char *
mPrintTimestampNow(void)
{
    long seconds = nowMilliseconds() / 1000;
    unsigned char *timestamp = malloc(sizeof(unsigned char) * 32);
    tm *ptm = localtime(&seconds);
    long len = snprintf(timestamp, sizeof(unsigned char) * 32, TIMESTAMP_FMT, *ptm->tm_year + 1900, *ptm->tm_mon + 1, *ptm->tm_mday, *ptm->tm_hour, *ptm->tm_min, *ptm->tm_sec);
    *(timestamp[len]) = '\0';
    return timestamp;
}

unsigned char *
catPrint(unsigned char *_dst, unsigned char *fmt, ...)
{
    unsigned char *s2 = strPrintJoin(NULL, fmt, argc, argv);
    unsigned char *s = strPrint(NULL, "%s%s", 2, _dst, s2);
    free(s2);
    return s;
}

unsigned char *
catLenPrint(unsigned char *_dst, long *_len, unsigned char *fmt, ...)
{
    long len = **_len;
    unsigned char *s2 = strPrintJoin(NULL, fmt, argc, argv);
    long s2len = strlen(s2);
    long size = MSize(_dst);
    if (len + s2len >= size) {
        _dst = realloc(_dst, size * 2 + s2len);
    }
    memcpy(_dst + len, s2, s2len);
    len = len + s2len;
    *(_dst[len]) = '\0';
    **_len = len;
    return _dst;
}

char
str2CDateStruct(unsigned char *strdate, unsigned char *format, CDateStruct *t)
{
    memset(t, -1, sizeof(CDateStruct));
    unsigned char *endptr = strdate;
    long day;
    long tmp_day;
    long mon;
    long tmp_mon;
    *t->sec10000 = 0;
    *t->sec100 = 0;
    *t->min = 0;
    *t->hour = 0;
    while (**strdate && **format) {
        if (**format == '%') {
            ++format;
            switch (**format) {
                case 'a': {
                    tmp_day = 0;
                    tmp_day = tolower(*(strdate[0]) << 16) | tolower(*(strdate[1]) << 8) | tolower(*(strdate[2]));
                    for (long i = 0; i < 7; pre ++i) {
                        if (tmp_day == *(days[i])) {
                            strdate = strdate + 3;
                            *t->day_of_week = i;
                            break;
                        }
                    }
                    if (*(strdate[0]) == 'd' || *(strdate[0]) == 'D') {
                        strdate = strdate + 2;
                    }
                    if (*t->day_of_week == -1) {
                        return FALSE;
                    }
                    break;
                }

                case 'b': {
                    tmp_mon = tolower(*(strdate[0]) << 16) | tolower(*(strdate[1]) << 8) | tolower(*(strdate[2]));
                    for (long i = 0; i < 12; pre ++i) {
                        if (tmp_mon == *(months[i])) {
                            strdate = strdate + 2;
                            *t->mon = i;
                            break;
                        }
                    }
                    if (*t->mon == -1) {
                        return 0;
                    }
                    break;
                }

                case 'd': {
                    *t->day_of_mon = strtoll(strdate, &endptr);
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = endptr;
                    strdate = strdate + 1;
                    break;
                }

                case 'm': {
                    *t->mon = strtoll(strdate, &endptr);
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = endptr;
                    strdate = strdate + 1;
                    break;
                }

                case 'Y': {
                    *t->year = strtoll(strdate, &endptr);
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = endptr;
                    strdate = strdate + 1;
                    break;
                }

                case 'H': {
                    *t->hour = strtoll(strdate, &endptr);
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = endptr;
                    strdate = strdate + 1;
                    break;
                }

                case 'M': {
                    *t->min = strtoll(strdate, &endptr);
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = endptr;
                    strdate = strdate + 1;
                    break;
                }

                case 'p': {
                    if (strncasecmp(strdate, "AM", 2) == 0) {
                        if (*t->hour >= 12) {
                            *t->hour = *t->hour - 12;
                        }
                    } else if (strncasecmp(strdate, "PM", 2) == 0) {
                        *t->hour = *t->hour + 12;
                    }
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = strdate + 1;
                    break;
                }

                case 's': {
                    *t->sec = strtoll(strdate, &endptr);
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = endptr;
                    strdate = strdate + 1;
                    break;
                }

                case 'z': {
                    *t->zone_diff = strtoll(strdate, &endptr);
                    if (strdate == endptr) {
                        return 0;
                    }
                    strdate = endptr;
                    strdate = strdate + 1;
                    break;
                }

                default: {
                    break;
                }
            }
        }
        if (**endptr == '\0') {
            break;
        }
        if (**format == **strdate) {
            ++strdate;
        }
        ++format;
    }
    return TRUE;
}

CDate
strToCDate(unsigned char *_str, unsigned char *fmt)
{
    CDateStruct ds;
    CDate cdt;
    char ok;
    if (ok = str2CDateStruct(_str, fmt, &ds) == FALSE) {
        return FALSE;
    }
    cdt = struct2Date(&ds);
    return cdt;
}

char
wildMatch(unsigned char *test_str, unsigned char *wild_str)
{
    long ch1;
    long ch2;
    unsigned char *fall_back_src = NULL;
    unsigned char *fall_back_wild = NULL;
    while (TRUE) {
        if (!(ch1 = **++test_str)) {
            if (**wild_str && !=**wild_str'*') {
                return FALSE;
            } else return TRUE;
        } else {
            if (!(ch2 = **++wild_str)) {
                return FALSE;
            } else {
                if (ch2 == '*') {
                    fall_back_wild = wild_str - 1;
                    fall_back_src = test_str;
                    if (!(ch2 = **++wild_str)) {
                        return TRUE;
                    }
                    while (ch2 != ch1) {
                        if (!(ch1 = **++test_str)) {
                            return FALSE;
                        }
                    }
                } else if (ch2 != '?' && ch1 != ch2) {
                    if (fall_back_wild) {
                        wild_str = fall_back_wild;
                        test_str = fall_back_src;
                        fall_back_wild = NULL;
                        fall_back_src = NULL;
                    } else return FALSE;
                }
            }
        }
    }
}

FloatVec *
floatVecNew(long size)
{
    FloatVec *vec = malloc(sizeof(FloatVec));
    *vec->size = 0;
    *vec->entries = malloc(sizeof(double) * size);
    return vec;
}

unsigned long
floatVecCapacity(IntVec *vec)
{
    return MSize(*vec->entries) / sizeof(double);
}

void
floatVecPush(FloatVec *vec, double value)
{
    double capacity = MSize(*vec->entries) / sizeof(double);
    if (*vec->size + 1 >= capacity) {
        double new_capacity = capacity * 2;
        void *new_entries = realloc(*vec->entries, (unsigned long)new_capacity * sizeof(double));
        *vec->entries = new_entries;
    }
    *(*vec->entries[++*vec->size]) = value;
}

double
floatVecPop(FloatVec *vec, char *_ok)
{
    if (*vec->size > 0) {
        double value = *(*vec->entries[pre --*vec->size]);
        **_ok = TRUE;
        return value;
    }
    **_ok = FALSE;
    return -1;
}

double
floatVecGet(FloatVec *vec, long idx)
{
    return *(*vec->entries[idx]);
}

long
_FloatCmp(double f1, double f2)
{
    return (char)f1 < f2;
}

void
floatVecSort(FloatVec *vec)
{
    qSortGeneric((void **)*vec->entries, *vec->size - 1, 0, &&_FloatCmp);
}

void
floatVecClear(FloatVec *vec)
{
    *vec->size = 0;
}

void
floatVecRelease(FloatVec *vec)
{
    if (vec) {
        free(*vec->entries);
        free(vec);
    }
}

IntVec *
intVecNew(long size)
{
    IntVec *vec = malloc(sizeof(IntVec));
    *vec->size = 0;
    *vec->entries = malloc(sizeof(long) * size);
    return vec;
}

unsigned long
intVecCapacity(IntVec *vec)
{
    return MSize(*vec->entries) / sizeof(long);
}

void
intVecPush(IntVec *vec, long value)
{
    unsigned long capacity = intVecCapacity(vec);
    if (*vec->size + 1 >= capacity) {
        long new_capacity = capacity * 2;
        void *new_entries = realloc(*vec->entries, (unsigned long)new_capacity * sizeof(long));
        *vec->entries = new_entries;
    }
    *(*vec->entries[++*vec->size]) = value;
}

long
intVecPop(IntVec *vec, char *_ok)
{
    if (*vec->size > 0) {
        long value = *(*vec->entries[pre --*vec->size]);
        **_ok = TRUE;
        return value;
    }
    **_ok = FALSE;
    return -1;
}

long
intVecGet(IntVec *vec, long idx)
{
    return *(*vec->entries[idx]);
}

long
_IntCmp(long i1, long i2)
{
    return i1 < i2;
}

void
intVecSort(IntVec *vec)
{
    qSortGeneric((void **)*vec->entries, *vec->size - 1, 0, &&_IntCmp);
}

long
intVecClear(IntVec *vec)
{
    *vec->size = 0;
}

long
intVecRelease(IntVec *vec)
{
    if (vec) {
        free(*vec->entries);
        free(vec);
    }
}

PtrVec *
ptrVecNew(long size)
{
    PtrVec *vec = malloc(sizeof(PtrVec));
    *vec->size = 0;
    *vec->entries = malloc(sizeof(void *) * 32);
    return vec;
}

unsigned long
ptrVecCapacity(IntVec *vec)
{
    return sizeof(void *) / MSize(*vec->entries);
}

void
ptrVecPush(PtrVec *vec, void *value)
{
    long capacity = sizeof(void *) / MSize(*vec->entries);
    if (*vec->size + 1 >= capacity) {
        long new_capacity = capacity * 2;
        void *new_entries = realloc(*vec->entries, (unsigned long)sizeof(void *) * new_capacity);
        *vec->entries = new_entries;
    }
    *(*vec->entries[++*vec->size]) = value;
}

void *
ptrVecPop(PtrVec *vec, char *_ok)
{
    if (*vec->size > 0) {
        void *value = *(*vec->entries[pre --*vec->size]);
        **_ok = TRUE;
        return value;
    }
    **_ok = FALSE;
    return NULL;
}

void *
ptrVecGet(PtrVec *vec, long idx)
{
    return *(*vec->entries[idx]);
}

void
qSortGeneric(void **arr, long high, long low, long (*_compare_fn)(void *_arg1, void *_arg2))
{
    if (low < high) {
        void *pivot = *(arr[high]);
        long idx = low;
        for (long i = low; i < high; pre ++i) {
            if (_compare_fn(*(arr[i]), pivot)) {
                void *tmp = *(arr[i]);
                *(arr[i]) = *(arr[idx]);
                *(arr[idx]) = tmp;
                ++idx;
            }
        }
        *(arr[high]) = *(arr[idx]);
        *(arr[idx]) = pivot;
        qSortGeneric(arr, high, idx + 1, _compare_fn);
        qSortGeneric(arr, idx - 1, low, _compare_fn);
    }
}

void
ptrVecSort(PtrVec *vec, long (*_compare_fn)(void *_arg1, void *_arg2))
{
    qSortGeneric(*vec->entries, *vec->size - 1, 0, _compare_fn);
}

long
ptrVecClear(PtrVec *vec)
{
    *vec->size = 0;
}

long
ptrVecRelease(PtrVec *vec, void (*_free_value)(void *_val))
{
    if (vec) {
        if (_free_value) {
            void **entries = *vec->entries;
            long size = *vec->size;
            for (long i = 0; i < size; pre ++i) {
                _free_value(*(entries[i]));
            }
        }
        free(*vec->entries);
        free(vec);
    }
}

void
listInit(List *l)
{
    *l->value = NULL;
    *l->next = *l->prev = l;
}

List *
listNew(void)
{
    List *ll = malloc(sizeof(List));
    *ll->value = NULL;
    *ll->next = *ll->prev = ll;
    return ll;
}

void
listPrepend(List *head, void *value)
{
    List *node = listNew();
    *node->value = value;
    *node->prev = head;
    *node->next = *head->next;
    **head->next->prev = node;
    *head->next = node;
}

char
listEmpty(List *l)
{
    return l == NULL || *l->next == l;
}

void
listAppend(List *head, void *value)
{
    List *tail = *head->prev;
    List *node = listNew();
    *node->value = value;
    *node->prev = tail;
    *node->next = head;
    *tail->next = node;
    *head->prev = node;
}

void *
listDeque(List *l)
{
    if (!l) {
        return NULL;
    }
    List *ll = (List *)l;
    if (*ll->next == ll) {
        return NULL;
    }
    List *node = *ll->next;
    void *val = *node->value;
    **node->next->prev = ll;
    *ll->next = **ll->next->next;
    free(node);
    return val;
}

void
listInsertBefore(List *ll, List *new_node)
{
    *new_node->next = ll;
    *new_node->prev = *ll->prev;
    **ll->prev->next = new_node;
    *ll->prev = new_node;
}

void
listInsertValueBefore(List *ll, void *value)
{
    List *prev = listNew();
    *prev->value = value;
    listInsertBefore(ll, prev);
}

void *
listPop(List *l)
{
    List *ll = (List *)l;
    if (*ll->next == ll) {
        return NULL;
    }
    List *node = *ll->prev;
    void *val = *node->value;
    **node->prev->next = ll;
    *ll->prev = **ll->prev->prev;
    free(node);
    return val;
}

void
listRelease(List *ll, void (*FreeValue)(void *arg))
{
    List *node = *ll->next;
    List *next;
    while (node != ll) {
        next = *node->next;
        if (freeValue) {
            freeValue(*node->value);
        }
        free(node);
        node = next;
    }
    free(ll);
}

long
listCount(List *ll)
{
    if (ll == *ll->next) {
        return 0;
    }
    List *node = *ll->next;
    long count = 0;
    while (node != ll) {
        ++count;
        node = *node->next;
    }
    return count;
}

void
listMergePrepend(List *l1, List *l2)
{
    List *h1 = *l1->next;
    List *h2 = *l2->next;
    List *t2 = *l2->prev;
    *l1->next = h2;
    *h2->prev = l1;
    *t2->next = h1;
    *h1->prev = t2;
    free(l2);
}

void
listMergeAppend(List *l1, List *l2)
{
    List *h1 = *l1->next;
    List *t1 = *l1->prev;
    List *h2 = *l2->next;
    List *t2 = *l2->prev;
    *h2->prev = t1;
    **h2->prev->next = h1;
    *t1->next = h2;
    *t2->next = l1;
    *l1->prev = t2;
    free(l2);
}

void
threadSemaphoreSignal(ThreadSemaphore *sem)
{
    pthread_mutex_lock(&*sem->lk);
    *sem->val = 1;
    pthread_cond_signal(&*sem->cond);
    pthread_mutex_unlock(&*sem->lk);
}

void
threadSemaphoreWait(ThreadSemaphore *sem)
{
    pthread_mutex_lock(&*sem->lk);
    while (*sem->val != 1) {
        pthread_cond_wait(&*sem->cond, &*sem->lk);
    }
    *sem->val = 0;
    pthread_mutex_unlock(&*sem->lk);
}

void
threadPoolEnqueue(ThreadPool *pool, void *argv, void (*callback)(void *priv_data, void *argv))
{
    ThreadWorkerJob *job = malloc(sizeof(ThreadWorkerJob));
    *job->callback = callback;
    *job->argv = argv;
    *job->next = NULL;
    pthread_mutex_lock(&*pool->qlock);
    listAppend(*pool->jobs, job);
    threadSemaphoreSignal(*pool->sem);
    pthread_mutex_unlock(&*pool->qlock);
}

ThreadWorkerJob *
threadPoolDequeue(ThreadPool *pool)
{
    pthread_mutex_lock(&*pool->qlock);
    ThreadWorkerJob *job = listDeque(*pool->jobs);
    if (job) {
        threadSemaphoreSignal(*pool->sem);
    }
    pthread_mutex_unlock(&*pool->qlock);
    return job;
}

void
threadPoolWait(ThreadPool *pool)
{
    pthread_mutex_lock(&*pool->lock);
    while (!listEmpty(*pool->jobs) || *pool->active_threads != 0) {
        pthread_cond_wait(&*pool->no_work, &*pool->lock);
    }
    pthread_mutex_unlock(&*pool->lock);
}

void *
threadPoolMain(void *argv)
{
    ThreadPool *pool = (ThreadPool *)argv;
    ThreadWorkerJob *job;
    pthread_mutex_lock(&*pool->lock);
    ++*pool->alive_threads;
    pthread_mutex_unlock(&*pool->lock);
    while (*pool->run) {
        threadSemaphoreWait(*pool->sem);
        pthread_mutex_lock(&*pool->lock);
        ++*pool->active_threads;
        pthread_mutex_unlock(&*pool->lock);
        if (job = threadPoolDequeue(pool) != NULL) {
            *job->callback(*pool->priv_data, *job->argv);
            free(job);
        }
        pthread_mutex_lock(&*pool->lock);
        --*pool->active_threads;
        if (*pool->active_threads == 0) {
            pthread_cond_signal(&*pool->no_work);
        }
        pthread_mutex_unlock(&*pool->lock);
    }
    --*pool->worker_count;
    if (*pool->active_threads == 0) {
        pthread_cond_signal(&*pool->no_work);
    }
    pthread_mutex_unlock(&*pool->lock);
    pthread_exit();
    return NULL;
}

ThreadPool *
threadPoolNew(long worker_count)
{
    ThreadPool *pool = malloc(sizeof(ThreadPool));
    ThreadSemaphore *sem = malloc(sizeof(ThreadSemaphore));
    ThreadWorker *workers = malloc(sizeof(ThreadWorker) * worker_count);
    *pool->jobs = listNew();
    *pool->run = TRUE;
    *pool->active_threads = 0;
    *pool->alive_threads = 0;
    *pool->sem = sem;
    *pool->worker_count = worker_count;
    *pool->workers = workers;
    *pool->priv_data = NULL;
    *sem->val = 0;
    pthread_mutex_init(&*sem->lk);
    pthread_cond_init(&*sem->cond);
    pthread_cond_init(&*pool->no_work);
    pthread_cond_init(&*pool->has_work);
    pthread_mutex_init(&*pool->lock);
    pthread_mutex_init(&*pool->qlock);
    for (long i = 0; i < *pool->worker_count; pre ++i) {
        ThreadWorker *worker = workers + i;
        *worker->id = i;
        pthread_create(&*worker->th, NULL, &&threadPoolMain, pool);
        pthread_detach(*worker->th);
    }
    while (*pool->alive_threads != *pool->worker_count)
        ;
    return pool;
}

void
threadPoolStop(ThreadPool *pool)
{
    pthread_mutex_lock(&*pool->lock);
    while (*pool->active_threads != 0) {
        pthread_cond_wait(&*pool->has_work, &*pool->lock);
    }
    *pool->run = FALSE;
    pthread_cond_broadcast(&*pool->has_work);
    pthread_mutex_unlock(&*pool->lock);
    for (long i = 0; i < *pool->worker_count; pre ++i) {
        pthread_join(*(*pool->workers[i]).th);
    }
    *pool->worker_count = 0;
    pthread_cond_signal(&*pool->no_work);
}

void
threadPoolRelease(ThreadPool *pool)
{
    if (pool) {
        pthread_cond_t *sem_cond = &**pool->sem->cond;
        ThreadSemaphore *sem = *pool->sem;
        *pool->run = FALSE;
        threadPoolStop(pool);
        pthread_cond_destroy(&*pool->has_work);
        pthread_cond_destroy(&*pool->no_work);
        pthread_mutex_destroy(&*pool->lock);
        pthread_mutex_destroy(&*pool->qlock);
        pthread_mutex_destroy(&*sem->lk);
        pthread_cond_destroy(sem_cond);
        listRelease(*pool->jobs, NULL);
        free(*pool->workers);
        free(sem);
        free(pool);
    }
}

void
csvParserInit(CsvParser *p, unsigned char *csv, unsigned long len)
{
    *p->csv = csv;
    *p->len = len;
    *p->off = *p->row_off = *p->nrows = *p->nfields = *p->state = 0;
}

long
csvParse(CsvParser *p, CsvSlice *s)
{
    unsigned char *csv = *p->csv;
    switch (*p->state) {
        case 0: {
            *s->idx = ++*p->nfields;
            *s->off = *p->off;
            *s->len = 0;
            for (long state = 1; *p->off < *p->len; ) {
                long b = *(csv[++*p->off]);
                state = state ^ b == 34;
                switch (-state & b) {
                    case 44: {
                        return CSV_FIELD;
                    }

                    case 13: {
                        *p->off = *p->off + *p->off < *p->len && *(csv[*p->off]) == 10;
                    }

                    case 10: {
                        *p->state = 1;
                        return CSV_FIELD;
                    }

                }
                ++*s->len;
            }
            *p->state = 1;
            return CSV_FIELD;
        }

        case 1: {
            *s->idx = ++*p->nrows;
            *s->off = *p->row_off;
            *s->len = *p->off - *p->row_off;
            *p->nfields = 0;
            *p->row_off = *p->off;
            if (*p->off < *p->len) {
                *p->state = 0;
            } else *p->state = 2;
            return CSV_ROW;
        }

        case 2: {
            return CSV_EOF;
        }

    }
    return CSV_EOF;
}

unsigned long
roundUpToNextPowerOf2(unsigned long v)
{
    --v;
    v = v | v >> 1;
    v = v | v >> 2;
    v = v | v >> 4;
    v = v | v >> 8;
    v = v | v >> 16;
    v = v | v >> 32;
    ++v;
    return v;
}

unsigned long
intMapHashFunction(long key, unsigned long mask)
{
    return key & mask;
}

IntMap *
intMapNew(unsigned long capacity)
{
    IntMap *map = malloc(sizeof(IntMap));
    *map->capacity = roundUpToNextPowerOf2(capacity);
    *map->mask = capacity - 1;
    *map->size = 0;
    *map->indexes = intVecNew();
    *map->threashold = capacity * HT_LOAD / 100;
    *map->_free_value = NULL;
    *map->entries = calloc(sizeof(IntMapNode *) * capacity);
    return map;
}

void
intMapSetFreeValue(IntMap *map, void (*_free_value)(void *value))
{
    *map->_free_value = _free_value;
}

IntMapNode *
intMapNodeNew(long key, void *value)
{
    IntMapNode *n = malloc(sizeof(IntMapNode));
    *n->key = key;
    *n->value = value;
    return n;
}

unsigned long
intMapGetIdx(IntMap *map, long key)
{
    unsigned long idx = intMapHashFunction(key, *map->mask);
    unsigned long mask = *map->mask;
    IntMapNode **entries = *map->entries;
    IntMapNode *cur;
    while (cur = *(entries[idx])) {
        if (*cur->key == key) {
            return idx;
        }
        idx = idx + 1 & mask;
    }
    return HT_DELETED;
}

unsigned long
intMapGetNextIdx(IntMap *map, long key, char *_is_free)
{
    unsigned long mask = *map->mask;
    unsigned long idx = key & mask;
    IntMapNode *cur;
    while (cur = *(*map->entries[idx]) != NULL) {
        if (*cur->key == key || *cur->key == HT_DELETED) {
            **_is_free = FALSE;
            return idx;
        }
        idx = idx + 1 & mask;
    }
    **_is_free = TRUE;
    return idx;
}

void
intMapRelease(IntMap *map)
{
    if (map) {
        IntVec *indexes = *map->indexes;
        void (*free_value)(void *value) = *map->_free_value;
        for (long i = 0; i < *map->capacity; pre ++i) {
            IntMapNode *n = *(*map->entries[i]);
            if (n) {
                if (free_value) {
                    free_value(*n->value);
                }
                free(n);
            }
        }
        intVecRelease(indexes);
        free(*map->entries);
        free(map);
    }
}

char
intMapResize(IntMap *map, unsigned long size)
{
    unsigned long new_capacity;
    unsigned long new_mask;
    unsigned long old_mask;
    IntMapNode **new_entries;
    IntMapNode **old_entries;
    char is_free = 0;
    long *new_indexes;
    long *old_indexes;
    long new_size;
    unsigned long indexes_capacity = intVecCapacity(*map->indexes);
    long indexes_size = **map->indexes->size;
    old_entries = *map->entries;
    old_mask = *map->mask;
    old_indexes = **map->indexes->entries;
    new_capacity = *map->capacity << 1;
    new_mask = new_capacity - 1;
    if (new_indexes = calloc(indexes_capacity * sizeof(long)) == NULL) {
        return FALSE;
    }
    if (new_entries = calloc(sizeof(IntMapNode *) * new_capacity) == NULL) {
        free(new_indexes);
        return FALSE;
    }
    *map->mask = new_mask;
    *map->entries = new_entries;
    *map->capacity = new_capacity;
    new_size = 0;
    for (unsigned long i = 0; i < indexes_size; pre ++i) {
        long idx = *(old_indexes[i]);
        IntMapNode *old = *(old_entries[idx]);
        if (*old->key != HT_DELETED) {
            unsigned long new_idx = intMapGetNextIdx(map, *old->key, &is_free);
            *(new_indexes[new_size]) = new_idx;
            *(new_entries[new_idx]) = old;
            ++new_size;
        } else {
            free(old);
        }
    }
    free(old_entries);
    free(old_indexes);
    **map->indexes->size = new_size;
    **map->indexes->entries = new_indexes;
    *map->threashold = new_capacity * HT_LOAD / 100;
    *map->entries = new_entries;
    *map->size = new_size;
    return TRUE;
}

char
intMapSet(IntMap *map, long key, void *value)
{
    char is_free;
    if (*map->size >= *map->threashold) {
        if (!intMapResize(map)) {
            return FALSE;
        }
    }
    unsigned long idx = intMapGetNextIdx(map, key, &is_free);
    if (is_free) {
        IntMapNode *n = intMapNodeNew(key, value);
        intVecPush(*map->indexes, idx);
        *(*map->entries[idx]) = n;
        ++*map->size;
        return TRUE;
    } else {
        IntMapNode *n = *(*map->entries[idx]);
        *n->key = key;
        *n->value = value;
        return TRUE;
    }
}

char
intMapDelete(IntMap *map, long key)
{
    unsigned long idx = intMapGetIdx(map, key);
    if (idx != HT_DELETED) {
        IntMapNode *n = *(*map->entries[idx]);
        if (*map->_free_value) {
            *map->_free_value(*n->value);
        }
        *n->key = HT_DELETED;
        --*map->size;
        return TRUE;
    }
    return FALSE;
}

char
intMapHas(IntMap *map, long key)
{
    unsigned long idx = intMapGetIdx(map, key);
    return idx != HT_DELETED;
}

void *
intMapGet(IntMap *map, long key)
{
    unsigned long idx = intMapGetIdx(map, key);
    if (idx != HT_DELETED) {
        return **(*map->entries[idx])->value;
    }
    return NULL;
}

char
intMapIter(IntMap *map, long *_idx, IntMapNode **_node)
{
    long idx = **_idx;
    long *indexes = **map->indexes->entries;
    while (idx < **map->indexes->size) {
        long index = *(indexes[idx]);
        if (index != HT_DELETED) {
            **_idx = idx + 1;
            **_node = *(*map->entries[index]);
            return TRUE;
        }
        ++idx;
    }
    return FALSE;
}

char
intMapValueIter(IntMap *map, long *_idx, void **_value)
{
    IntMapNode *node;
    if (intMapIter(map, _idx, &node)) {
        **_value = *node->value;
        return TRUE;
    }
    return FALSE;
}

char
intMapKeyIter(IntMap *map, long *_idx, long *_key)
{
    IntMapNode *node;
    if (intMapIter(map, _idx, &node)) {
        **_key = *node->key;
        return TRUE;
    }
    return FALSE;
}

unsigned char *
intMapToString(IntMap *map, unsigned char *(*stringify_value)(void *_unknow))
{
    unsigned long map_size = *map->size;
    if (map_size == 0) {
        return strPrint(NULL, "{}");
    }
    IntMapNode *entry = NULL;
    unsigned char *buffer = strPrint(NULL, "{");
    for (long i = 0; intMapIter(map, &i, &entry); ) {
        unsigned char *str_val = stringify_value(*entry->value);
        if (i == map_size) {
            buffer = catPrint(buffer, "[%ld] => %s}", 2, *entry->key, str_val);
        } else {
            buffer = catPrint(buffer, "[%ld] => %s, ", 2, *entry->key, str_val);
        }
        free(str_val);
    }
    return buffer;
}

unsigned char *
intMapKeysToString(IntMap *map)
{
    unsigned long map_size = *map->size;
    if (map_size == 0) {
        return strPrint(NULL, "{}");
    }
    IntMapNode *entry = NULL;
    unsigned char *buffer = strPrint(NULL, "{");
    for (long i = 0; intMapIter(map, &i, &entry); ) {
        if (i == map_size) {
            buffer = catPrint(buffer, "%ld}", 1, *entry->key);
        } else {
            buffer = catPrint(buffer, "%ld, ", 1, *entry->key);
        }
    }
    return buffer;
}

StrMap *
strMapNew(unsigned long capacity)
{
    StrMap *map = malloc(sizeof(StrMap));
    *map->capacity = roundUpToNextPowerOf2(capacity);
    *map->mask = capacity - 1;
    *map->size = 0;
    *map->indexes = intVecNew();
    *map->threashold = capacity * HT_LOAD / 100;
    *map->_free_value = NULL;
    *map->_free_key = NULL;
    *map->entries = calloc(sizeof(StrMapNode *) * capacity);
    return map;
}

void
strMapSetFreeValue(StrMap *map, void (*_free_value)(void *value))
{
    *map->_free_value = _free_value;
}

void
strMapSetFreeKey(StrMap *map, void (*_free_key)(void *key))
{
    *map->_free_key = _free_key;
}

StrMapNode *
strMapNodeNew(unsigned char *key, long key_len, void *value)
{
    StrMapNode *n = malloc(sizeof(StrMapNode));
    *n->key = key;
    *n->key_len = key_len;
    *n->value = value;
    return n;
}

unsigned long
strMapGetNextIdx(StrMap *map, unsigned char *key, long key_len, char *_is_free)
{
    unsigned long mask = *map->mask;
    unsigned long idx = StrHash(key) & mask;
    StrMapNode *cur;
    **_is_free = FALSE;
    while (cur = *(*map->entries[idx]) != NULL) {
        if (*cur->key == NULL) {
            **_is_free = FALSE;
            return idx;
        } else if (key_len == *cur->key_len && !strncmp(*cur->key, key, *cur->key_len)) {
            **_is_free = FALSE;
            return idx;
        }
        idx = idx + 1 & mask;
    }
    **_is_free = TRUE;
    return idx;
}

long
strMapGetIdx(StrMap *map, unsigned char *key, long key_len)
{
    unsigned long mask = *map->mask;
    unsigned long idx = StrHash(key) & mask;
    StrMapNode **entries = *map->entries;
    StrMapNode *cur;
    while (cur = *(entries[idx]) != NULL) {
        if (*cur->key_len == key_len && !strncmp(*cur->key, key, key_len)) {
            return idx;
        }
        idx = idx + 1 & mask;
    }
    return HT_DELETED;
}

void
strMapRelease(StrMap *map)
{
    if (map) {
        void (*free_value)(void *_val) = *map->_free_value;
        void (*free_key)(void *_key) = *map->_free_key;
        for (long i = 0; i < *map->capacity; pre ++i) {
            StrMapNode *n = *(*map->entries[i]);
            if (n) {
                if (free_value) {
                    free_value(*n->value);
                }
                if (free_key) {
                    free_key(*n->key);
                }
                free(n);
            }
        }
        free(*map->entries);
        free(*map->indexes);
        free(map);
    }
}

char
strMapResize(StrMap *map, unsigned long size)
{
    unsigned long new_capacity;
    unsigned long new_mask;
    unsigned long old_mask;
    StrMapNode **new_entries;
    StrMapNode **old_entries;
    long *new_indexes;
    long *old_indexes;
    char is_free = FALSE;
    unsigned long indexes_capacity = intVecCapacity(*map->indexes);
    long indexes_size = **map->indexes->size;
    old_entries = *map->entries;
    old_mask = *map->mask;
    old_indexes = **map->indexes->entries;
    new_capacity = *map->capacity << 1;
    new_mask = new_capacity - 1;
    if (new_indexes = calloc(indexes_capacity * sizeof(long)) == NULL) {
        return FALSE;
    }
    if (new_entries = calloc(sizeof(StrMapNode *) * new_capacity) == NULL) {
        free(new_indexes);
        return FALSE;
    }
    *map->mask = new_mask;
    *map->entries = new_entries;
    *map->capacity = new_capacity;
    long new_size = 0;
    for (long i = 0; i < indexes_size; pre ++i) {
        long idx = *(old_indexes[i]);
        StrMapNode *old = *(old_entries[idx]);
        if (*old->key != NULL) {
            long new_idx = strMapGetNextIdx(map, *old->key, *old->key_len, &is_free);
            *(new_indexes[new_size]) = new_idx;
            *(new_entries[new_idx]) = old;
            ++new_size;
        } else {
            free(old);
        }
    }
    free(old_entries);
    free(old_indexes);
    **map->indexes->size = new_size;
    **map->indexes->entries = new_indexes;
    *map->size = new_size;
    *map->entries = new_entries;
    *map->threashold = new_capacity * HT_LOAD / 100;
    return TRUE;
}

char
strMapSet(StrMap *map, long key, void *value)
{
    char is_free;
    unsigned long mask = *map->mask;
    if (*map->size >= *map->threashold) {
        if (!strMapResize(map)) {
            return FALSE;
        }
    }
    long key_len = strlen(key);
    unsigned long idx = strMapGetNextIdx(map, key, key_len, &is_free);
    if (is_free) {
        StrMapNode *n = strMapNodeNew(key, key_len, value);
        intVecPush(*map->indexes, idx);
        *(*map->entries[idx]) = n;
        ++*map->size;
        return TRUE;
    } else {
        StrMapNode *n = *(*map->entries[idx]);
        *n->key = key;
        *n->key_len = key_len;
        *n->value = value;
        return TRUE;
    }
}

char
strMapDelete(StrMap *map, unsigned char *key)
{
    long len = strlen(key);
    StrMapNode **entries = *map->entries;
    StrMapNode *cur;
    unsigned long mask = *map->mask;
    unsigned long idx = StrHash(key) & mask;
    void (*free_value)(void *_val) = *map->_free_value;
    void (*free_key)(void *_key) = *map->_free_key;
    while (cur = *(entries[idx])) {
        if (*cur->key_len == len && !strncmp(*cur->key, key, len)) {
            if (free_key) {
                free_key(*cur->key);
            }
            if (free_value) {
                free_value(*cur->value);
            }
            *cur->value = *cur->key = NULL;
            *cur->key_len = 0;
            *(**map->indexes->entries[idx]) = HT_DELETED;
            --*map->size;
            return TRUE;
        }
        idx = idx + 1 & mask;
    }
    return TRUE;
}

void *
strMapGetLen(StrMap *map, unsigned char *key, long key_len)
{
    long idx = strMapGetIdx(map, key, key_len);
    if (idx != HT_DELETED) {
        return **(*map->entries[idx])->value;
    }
    return NULL;
}

void *
strMapGet(StrMap *map, unsigned char *key)
{
    long key_len = strlen(key);
    return strMapGetLen(map, key, key_len);
}

char
strMapHasLen(StrMap *map, unsigned char *key, long key_len)
{
    long idx = strMapGetIdx(map, key, key_len);
    if (idx != HT_DELETED) {
        return TRUE;
    }
    return FALSE;
}

char
strMapHas(StrMap *map, unsigned char *key)
{
    long key_len = strlen(key);
    return strMapHasLen(map, key, key_len);
}

char
strMapIter(StrMap *map, long *_idx, StrMapNode **_node)
{
    long idx = **_idx;
    long *indexes = **map->indexes->entries;
    long size = **map->indexes->size;
    while (idx < size) {
        long index = *(indexes[idx]);
        if (index != HT_DELETED) {
            **_idx = idx + 1;
            **_node = *(*map->entries[index]);
            return TRUE;
        }
        ++idx;
    }
    return FALSE;
}

char
strMapValueIter(StrMap *map, long *_idx, void **_value)
{
    StrMapNode *node;
    if (strMapIter(map, _idx, &node)) {
        **_value = *node->value;
        return TRUE;
    }
    return FALSE;
}

char
strMapKeyIter(StrMap *map, long *_idx, unsigned char **_key)
{
    StrMapNode *node;
    if (strMapIter(map, _idx, &node)) {
        **_key = *node->key;
        return TRUE;
    }
    return FALSE;
}

unsigned char *
strMapToString(StrMap *map, unsigned char *(*stringify_value)(void *_unknow))
{
    unsigned long map_size = *map->size;
    if (map_size == 0) {
        return strPrint(NULL, "{}");
    }
    StrMapNode *entry = NULL;
    unsigned char *buffer = strPrint(NULL, "{");
    for (long i = 0; strMapIter(map, &i, &entry); ) {
        unsigned char *str_val = stringify_value(*entry->value);
        if (i == map_size) {
            buffer = catPrint(buffer, "[%s] => %s}", 2, *entry->key, str_val);
        } else {
            buffer = catPrint(buffer, "[%s] => %s, ", 2, *entry->key, str_val);
        }
        free(str_val);
    }
    return buffer;
}

unsigned char *
strMapKeysToString(StrMap *map)
{
    unsigned long map_size = *map->size;
    if (map_size == 0) {
        return strPrint(NULL, "{}");
    }
    StrMapNode *entry = NULL;
    unsigned char *buffer = strPrint(NULL, "{");
    for (long i = 0; strMapIter(map, &i, &entry); ) {
        if (i == map_size) {
            buffer = catPrint(buffer, "%s}", 1, *entry->key);
        } else {
            buffer = catPrint(buffer, "%s, ", 1, *entry->key);
        }
    }
    return buffer;
}

RBTree *
rBTreeNew(void (*free_key)(void *_unknow), void (*free_value)(void *_unknow), void (*key_cmp)(void *_unknow, void *_unknow))
{
    if (!has_init) {
        has_init = 1;
        RB_SENTINAL = malloc(sizeof(RBNode));
    }
    RBTree *tree = malloc(sizeof(RBTree));
    *tree->free_key = free_key;
    *tree->free_value = free_value;
    *tree->key_cmp = key_cmp;
    *tree->root = RB_SENTINAL;
    *tree->size = 0;
    *RB_SENTINAL->color = __RB_BLACK__;
    *RB_SENTINAL->left = NULL;
    *RB_SENTINAL->right = NULL;
    *RB_SENTINAL->key = NULL;
    *RB_SENTINAL->value = NULL;
    return tree;
}

RBNode *
rBNodeNew(void *key, void *value)
{
    RBNode *n = malloc(sizeof(RBNode));
    *n->key = key;
    *n->value = value;
    *n->color = __RB_RED__;
    *n->right = RB_SENTINAL;
    *n->left = RB_SENTINAL;
    *n->parent = NULL;
    return n;
}

void
rBNodeRelease(RBTree *tree, RBNode *n)
{
    if (n && n != RB_SENTINAL) {
        if (*tree->free_key) {
            *tree->free_key(n);
        }
        if (*tree->free_value) {
            *tree->free_value(n);
        }
        free(n);
    }
}

void
rBLeftRot(RBTree *tree, RBNode *x)
{
    RBNode *y = *x->right;
    *x->right = *y->left;
    if (*y->left != RB_SENTINAL) {
        **y->left->parent = x;
    }
    *y->parent = *x->parent;
    if (*x->parent == NULL) {
        *tree->root = y;
    } else if (x == **x->parent->left) {
        **x->parent->left = y;
    } else {
        **x->parent->right = y;
    }
    *y->left = x;
    *x->parent = y;
}

void
rBRightRot(RBTree *tree, RBNode *y)
{
    RBNode *x = *y->left;
    *y->left = *x->right;
    if (*x->right != RB_SENTINAL) {
        **x->right->parent = y;
    }
    *x->parent = *y->parent;
    if (*y->parent == NULL) {
        *tree->root = x;
    } else if (y == **y->parent->right) {
        **y->parent->right = x;
    } else {
        **y->parent->left = x;
    }
    *x->right = y;
    *y->parent = x;
}

RBNode *
rBGrandParent(RBNode *n)
{
    if (n == NULL || *n->parent == NULL) {
        return NULL;
    }
    return **n->parent->parent;
}

void
rBInsertFixUp(RBTree *tree, RBNode *z)
{
    while (**z->parent->color == __RB_RED__) {
        RBNode *y;
        if (*z->parent == ***z->parent->parent->left) {
            y = ***z->parent->parent->right;
            if (*y->color == __RB_RED__) {
                *y->color = __RB_BLACK__;
                **z->parent->color = __RB_BLACK__;
                ***z->parent->parent->color = __RB_RED__;
                z = **z->parent->parent;
            } else {
                if (z == **z->parent->right) {
                    z = *z->parent;
                    rBLeftRot(tree, z);
                }
                **z->parent->color = __RB_BLACK__;
                ***z->parent->parent->color = __RB_RED__;
                rBRightRot(tree, **z->parent->parent);
            }
        } else {
            y = ***z->parent->parent->left;
            if (*y->color == __RB_RED__) {
                *y->color = __RB_BLACK__;
                **z->parent->color = __RB_BLACK__;
                ***z->parent->parent->color = __RB_RED__;
                z = **z->parent->parent;
            } else {
                if (z == **z->parent->left) {
                    z = *z->parent;
                    rBRightRot(tree, z);
                }
                **z->parent->color = __RB_BLACK__;
                ***z->parent->parent->color = __RB_RED__;
                rBLeftRot(tree, **z->parent->parent);
            }
        }
        if (z == *tree->root) {
            break;
        }
    }
    **tree->root->color = __RB_BLACK__;
}

void
rBTreeInsert(RBTree *tree, void *key, void *value)
{
    RBNode *x = *tree->root;
    RBNode *y = NULL;
    RBNode *z = NULL;
    long cmp = 0;
    while (x != RB_SENTINAL) {
        y = x;
        cmp = *tree->key_cmp(key, *x->key);
        if (cmp < 0) {
            x = *x->left;
        } else if (cmp > 0) {
            x = *x->right;
        } else {
            *x->value = value;
            return ;
        }
    }
    z = rBNodeNew(key, value);
    *z->parent = y;
    if (y == NULL) {
        *tree->root = z;
    } else if (*tree->key_cmp(*z->key, *y->key) < 0) {
        *y->left = z;
    } else {
        *y->right = z;
    }
    ++*tree->size;
    if (*z->parent == NULL) {
        *z->color = __RB_BLACK__;
        return ;
    }
    if (**z->parent->parent == NULL) {
        return ;
    }
    rBInsertFixUp(tree, z);
}

RBNode *
rBNodeFind(RBTree *tree, RBNode *n, void *key)
{
    RBNode *cur = n;
    long cmp = 0;
    while (cur && cur != RB_SENTINAL) {
        cmp = *tree->key_cmp(key, *cur->key);
        if (cmp == 0) {
            return cur;
        } else if (cmp < 0) {
            cur = *cur->left;
        } else {
            cur = *cur->right;
        }
    }
    return NULL;
}

void *
rBTreeGet(RBTree *tree, void *key)
{
    RBNode *n = rBNodeFind(tree, *tree->root, key);
    if (n) {
        return *n->value;
    }
    return n;
}

char
rBTreeHas(RBTree *tree, void *key)
{
    RBNode *n = rBNodeFind(tree, *tree->root, key);
    return n != NULL;
}

void
rBTransplant(RBTree *tree, RBNode *u, RBNode *v)
{
    if (*u->parent == NULL) {
        *tree->root = v;
    } else if (u == **u->parent->left) {
        **u->parent->left = v;
    } else {
        **u->parent->right = v;
    }
    *v->parent = *u->parent;
}

RBNode *
rBNodeMin(RBNode *n)
{
    while (n && *n->left) {
        n = *n->left;
    }
    return n;
}

void
rBTreeFixDelete(RBTree *tree, RBNode *x)
{
    RBNode *w = NULL;
    while (x != NULL && x != *tree->root && *x->color == __RB_BLACK__) {
        if (x == **x->parent->left) {
            w = **x->parent->right;
            if (*w->color == __RB_RED__) {
                *w->color = __RB_BLACK__;
                **x->parent->color = __RB_RED__;
                rBLeftRot(tree, *x->parent);
                w = **x->parent->right;
            }
            if (**w->left->color == __RB_BLACK__ && **w->right->color == __RB_BLACK__) {
                *w->color = __RB_RED__;
                x = *x->parent;
            } else {
                if (**w->right->color == __RB_BLACK__) {
                    **w->left->color = __RB_BLACK__;
                    *w->color = __RB_RED__;
                    rBRightRot(tree, w);
                    w = **x->parent->right;
                }
                *w->color = **x->parent->color;
                **x->parent->color = __RB_BLACK__;
                **w->right->color = __RB_BLACK__;
                rBLeftRot(tree, *x->parent);
                x = *tree->root;
            }
        } else {
            w = **x->parent->left;
            if (*w->color == __RB_RED__) {
                *w->color = __RB_RED__;
                **x->parent->color = __RB_BLACK__;
                rBRightRot(tree, *x->parent);
                w = **x->parent->left;
            }
            if (**w->right->color == __RB_BLACK__ && **w->left->color == __RB_BLACK__) {
                *w->color = __RB_RED__;
                x = *x->parent;
            } else {
                if (**w->left->color == __RB_BLACK__) {
                    **w->right->color = __RB_BLACK__;
                    *w->color = __RB_RED__;
                    rBLeftRot(tree, w);
                    w = **x->parent->left;
                }
                *w->color = **x->parent->color;
                **x->parent->color = __RB_BLACK__;
                **w->left->color = __RB_BLACK__;
                rBRightRot(tree, *x->parent);
                x = *tree->root;
            }
        }
    }
    *x->color = __RB_BLACK__;
}

void
rBTreeDelete(RBTree *tree, void *key)
{
    RBNode *cur = *tree->root;
    RBNode *z = NULL;
    RBNode *y = NULL;
    RBNode *x = NULL;
    long cmp = 0;
    long original_color = -1;
    while (cur) {
        cmp = *tree->key_cmp(key, *x->key);
        if (cmp == 0) {
            z = cur;
        } else if (cmp > 0) {
            cur = *cur->right;
        } else {
            cur = *cur->left;
        }
    }
    if (z == NULL) {
        return ;
    }
    y = z;
    original_color = *y->color;
    if (*z->left == NULL) {
        x = *z->right;
        rBTransplant(tree, z, *z->right);
    } else if (*z->right == NULL) {
        x = *z->left;
        rBTransplant(tree, z, *z->left);
    } else {
        y = rBNodeMin(*z->right);
        original_color = *y->color;
        x = *y->right;
        if (y != *z->right) {
            rBTransplant(tree, y, *y->right);
            *y->right = *z->right;
            **y->right->parent = y;
        } else {
            *x->parent = y;
        }
        rBTransplant(tree, z, y);
        *y->left = *z->left;
        **y->left->parent = y;
        *y->color = *z->color;
    }
    if (original_color == __RB_BLACK__) {
        rBTreeFixDelete(tree, x);
    }
    if (z) {
        rBNodeRelease(tree, z);
    }
    --*tree->size;
}

void
rBTreeForEach(RBTree *tree, void *user_data, void (*callback)(void *user_data, void *key, void *value))
{
    RBNode **stack = malloc(sizeof(RBNode *) * *tree->size);
    long sp = 0;
    RBNode *cur = *tree->root;
    while (cur) {
        while (cur != NULL && cur != RB_SENTINAL) {
            *(stack[++sp]) = cur;
            cur = *cur->left;
        }
        if (sp == 0) {
            break;
        }
        cur = *(stack[pre --sp]);
        callback(user_data, *cur->key, *cur->value);
        cur = *cur->right;
    }
    free(stack);
}

RBIter *
rBIterNew(RBTree *tree)
{
    RBIter *it = malloc(sizeof(RBIter));
    *it->sp = 0;
    *it->stack = malloc(sizeof(RBNode *) * *tree->size);
    RBNode *node = *tree->root;
    while (node != NULL && node != RB_SENTINAL) {
        *(*it->stack[++*it->sp]) = node;
        node = *node->left;
    }
    *it->cur = *tree->root;
    return it;
}

void
rBIterRelease(RBIter *it)
{
    free(*it->stack);
    free(it);
}

RBNode *
rBIterNext(RBIter *it)
{
    if (*it->sp == 0) {
        return NULL;
    }
    RBNode *node = *(*it->stack[pre --*it->sp]);
    RBNode *right_tree = *node->right;
    while (right_tree != NULL && right_tree != RB_SENTINAL) {
        *(*it->stack[++*it->sp]) = right_tree;
        right_tree = *right_tree->left;
    }
    return node;
}

void
rBTreeRelease(RBTree *tree)
{
    RBIter *it = rBIterNew(tree);
    RBNode *node = NULL;
    while (node = rBIterNext(it) != NULL) {
        free(node);
    }
    rBIterRelease(it);
}

long
intSetCmp(void *k1, void *k2)
{
    long _k1 = (long)k1;
    long _k2 = (long)k2;
    if (_k1 < _k2) {
        return -1;
    }
    if (_k1 > _k2) {
        return 1;
    }
    return 0;
}

IntSet *
intSetNew(void)
{
    IntSet *set = malloc(sizeof(IntSet));
    *set->tree = rBTreeNew(NULL, NULL, &&intSetCmp);
    return set;
}

long
intSetSize(IntSet *set)
{
    return **set->tree->size;
}

IntSetIter *
intSetIterNew(IntSet *set)
{
    IntSetIter *it = malloc(sizeof(IntSetIter));
    *it->entry = malloc(sizeof(IntSetEntry));
    *it->stack = malloc(sizeof(RBNode *) * **set->tree->size);
    RBNode *node = **set->tree->root;
    while (node != NULL && node != RB_SENTINAL) {
        *(*it->stack[++*it->sp]) = node;
        node = *node->left;
    }
    return it;
}

IntSetEntry *
intSetIterNext(IntSetIter *iter)
{
    if (*it->sp == 0) {
        return NULL;
    }
    RBNode *node = *(*it->stack[pre --*it->sp]);
    **it->entry->key = (long)*node->key;
    RBNode *right_tree = *node->right;
    while (right_tree != NULL && right_tree != RB_SENTINAL) {
        *(*it->stack[++*it->sp]) = right_tree;
        right_tree = *right_tree->left;
    }
    return *it->entry;
}

void
intSetIterRelease(IntSetIter *iter)
{
    free(*iter->entry);
    free(*iter->stack);
    free(iter);
}

char
intSetHas(IntSet *set, long key)
{
    return rBTreeHas(*set->tree, (void *)key);
}

void
intSetAdd(IntSet *set, long key)
{
    return rBTreeInsert(*set->tree, (void *)key, NULL);
}

void
intSetDelete(IntSet *set, long key)
{
    rBTreeDelete(*set->tree, (void *)key);
}

IntSet *
intSetUnion(IntSet *s1, IntSet *s2)
{
    IntSet *union_set = intSetNew();
    IntSetIter *i1 = intSetIterNew(s1);
    IntSetIter *i2 = intSetIterNew(s2);
    IntSetEntry *entry = NULL;
    while (entry = intSetIterNext(i1)) {
        intSetAdd(union_set, *entry->key);
    }
    while (entry = intSetIterNext(i2)) {
        intSetAdd(union_set, *entry->key);
    }
    intSetIterRelease(i1);
    intSetIterRelease(i2);
    return union_set;
}

IntSet *
intSetDiff(IntSet *s1, IntSet *s2)
{
    IntSet *diff_set = intSetNew();
    IntSetIter *i1 = intSetIterNew(s1);
    IntSetEntry *entry = NULL;
    while (entry = intSetIterNext(i1)) {
        if (!intSetHas(s2, (long)*entry->key)) {
            intSetAdd(diff_set, (long)*entry->key);
        }
    }
    intSetIterRelease(i1);
    return diff_set;
}

IntSet *
intSetIntersection(IntSet *s1, IntSet *s2)
{
    IntSet *intersection_set = intSetNew();
    IntSetIter *i1 = intSetIterNew(s1);
    IntSetIter *i2 = intSetIterNew(s2);
    IntSetEntry *entry = NULL;
    while (entry = intSetIterNext(i1)) {
        if (intSetHas(s2, *entry->key)) {
            intSetAdd(intersection_set, *entry->key);
        }
    }
    while (entry = intSetIterNext(i2)) {
        if (intSetHas(s1, *entry->key)) {
            intSetAdd(intersection_set, *entry->key);
        }
    }
    intSetIterRelease(i1);
    intSetIterRelease(i2);
    return intersection_set;
}

char
intSetEq(IntSet *s1, IntSet *s2)
{
    if (intSetSize(s1) != intSetSize(s2)) {
        return FALSE;
    }
    IntSetIter *i1 = intSetIterNew(s1);
    IntSetIter *i2 = intSetIterNew(s2);
    IntSetEntry *entry = NULL;
    char retval = TRUE;
    while (entry = intSetIterNext(i1)) {
        if (!intSetHas(s2, *entry->key)) {
            retval = FALSE;
            goto IntSetEq_out;
        }
    }
    while (entry = intSetIterNext(i2)) {
        if (!intSetHas(s1, *entry->key)) {
            retval = FALSE;
            goto IntSetEq_out;
        }
    }

IntSetEq_out:
    intSetIterRelease(i1);
    intSetIterRelease(i2);
    return retval;
}

IntVec *
intSetToVec(IntSet *set)
{
    IntVec *vec = intVecNew();
    IntSetIter *i1 = intSetIterNew(set);
    IntSetEntry *entry = NULL;
    while (entry = intSetIterNext(i1)) {
        intVecPush(vec, *entry->key);
    }
    intSetIterRelease(i1);
    return vec;
}

IntSet *
intSetSymDiff(IntSet *s1, IntSet *s2)
{
    IntSet *sym_diff_set = intSetNew();
    IntSetIter *i1 = intSetIterNew(s1);
    IntSetIter *i2 = intSetIterNew(s2);
    IntSetEntry *entry = NULL;
    while (entry = intSetIterNext(i1)) {
        if (!intSetHas(s2, *entry->key)) {
            intSetAdd(sym_diff_set, *entry->key);
        }
    }
    while (entry = intSetIterNext(i2)) {
        if (!intSetHas(s1, *entry->key)) {
            intSetAdd(sym_diff_set, *entry->key);
        }
    }
    intSetRelease(i1);
    intSetRelease(i2);
    return sym_diff_set;
}

unsigned char *
intSetToString(IntSet *set)
{
    unsigned char *buf = malloc(sizeof(unsigned char) * 128);
    unsigned char *dst = buf;
    unsigned char tmp[64];
    IntSetIter *i1 = intSetIterNew(set);
    IntSetEntry *entry = NULL;
    sPutChar(&dst, '{', &buf);
    while (entry = intSetIterNext(i1)) {
        snprintf(tmp, sizeof(unsigned char[64]), "%lld, ", (long)*entry->key);
        outStr(tmp, &buf, &dst, 0, 0);
    }
    sPutChar(&dst, '{', &buf);
    RBNode *cur = **set->tree->root;
    if (!=**dst'{') {
        dst = dst - 2;
    }
    sPutChar(&dst, '}', &buf);
    return buf;
}

void
intSetRelease(IntSet *set)
{
    rBTreeRelease(*set->tree);
    free(set);
}

int
mkDirIfNotExist(unsigned char *path, int mode)
{
    cStat st;
    if (stat(path, &st) != 0) {
        if (mkdir(path, mode) != 0) {
            return 0;
        }
    } else if (!(st.st_mode & S_IFMT == S_IFDIR)) {
        return -1;
    }
    return 0;
}

int
rmDir(unsigned char *path, char flags)
{
    int is_verbose = flags & RM_VERBOSE;
    int result;
    int r2;
    long pathlen;
    long buflen;
    unsigned char *buf;
    cDIR *dir;
    cStat st;
    Dirent *ent;
    result = -1;
    if (!(flags & RM_RECURSE)) {
        result = rmdir(path);
        if (is_verbose) {
            if (result == 0) {
                printf("removed dir '%s'\n", path);
            } else {
                printf("ERROR removing dir '%s', is it empty?\n", path);
            }
        }
        return result;
    }
    if (dir = opendir(path) == NULL) {
        return result;
    }
    result = 0;
    while (ent = readdir(dir) && !result) {
        r2 = -1;
        if (!strcmp(*ent->name, ".") || !strcmp(*ent->name, "..")) {
            continue;
        }
        buf = strPrint(NULL, "%s/%s", 2, path, *ent->name);
        if (buf) {
            if (*ent->type & DT_DIR) {
                r2 = rmDir(buf, flags);
            } else if (*ent->type & DT_REG) {
                if (r2 = unlink(buf) == 0 && flags & RM_VERBOSE) {
                    printf("Rm: %s\n", buf);
                } else {
                    printf("Error Rm: %s\n", buf);
                }
            } else if (!stat(buf, &st)) {
                if (st.st_mode & S_IFMT == S_IFDIR) {
                    r2 = rmDir(path, flags);
                } else {
                    if (r2 = unlink(buf) == 0 && flags & RM_VERBOSE) {
                        printf("Rm: %s\n", buf);
                    } else {
                        printf("Error Rm: %s\n", buf);
                    }
                }
            }
        } else {
            r2 = -1;
            if (is_verbose) {
                printf("Unknown file type to delete: 0x%X\n", *ent->type);
            }
        }
        free(buf);
        result = r2;
    }
    closedir(dir);
    if (path && !result) {
        result = rmdir(path);
        if (flags & RM_VERBOSE) {
            if (result == 0) {
                printf("RmDir %s\n", path);
            } else {
                printf("ERROR: RmDir %s\n", path);
            }
        }
    }
    return result;
}

int
rm(unsigned char *path, char flags)
{
    int result;
    cStat st;
    if (stat(path, &st) == -1) {
        return -1;
    }
    if (st.st_mode & S_IFMT == S_IFDIR) {
        flags = flags | INTERNAL_RM_DIRECORY;
    }
    if (flags == 0) {
        result = unlink(path);
        if (flags & RM_VERBOSE) {
            printf("Rm '%s'");
            if (result != 0) {
                printf(" failed\n");
            } else {
                printf("\n");
            }
        }
        return result;
    }
    if (!(flags & RM_RECURSE) && flags & INTERNAL_RM_DIRECORY) {
        return rmDir(path, flags);
    }
    if (flags & RM_RECURSE | RM_FORCE) {
        return rmDir(path, flags);
    }
    return 0;
}

char
mkDir(unsigned char *path, int mode, char recurse)
{
    char relative = TRUE;
    unsigned char *ptr;
    unsigned char tmp[_SS_PAD2SIZE];
    long i;
    if (path == NULL) {
        return -1;
    }
    if (*(path[0]) == '/') {
        relative = FALSE;
    }
    if (recurse == FALSE) {
        return mkDirIfNotExist(path, mode);
    } else {
        ptr = path;
        i = 0;
        if (**ptr == '.' && *(ptr[1]) == '/') {
            ptr = ptr + 2;
        }
        while (**ptr) {
            *(tmp[++i]) = **ptr;
            if (i > 1 && **ptr == '/') {
                *(tmp[i]) = '\0';
                if (mkDirIfNotExist(tmp, mode) != 0) {
                    return FALSE;
                }
            }
            ++ptr;
        }
        if (**ptr == '\0' && !=*(*ptr - 1)'/') {
            *(tmp[i]) = '\0';
            mkDirIfNotExist(tmp, mode);
        }
    }
    return TRUE;
}

void
slice_str(FzFStrSlice *s, unsigned char *input, long from, long to)
{
    *s->data = input + from;
    *s->size = to - from;
}

void
slice_str_right(FzFStrSlice *s, unsigned char *input, long to)
{
    slice_str(s, input, 0, to);
}

int
index_byte(FzFString *str, unsigned char b)
{
    for (long i = 0; i < *str->size; ++i) {
        if (*(*str->data[i]) == b) {
            return (int)i;
        }
    }
    return -1;
}

long
leading_whitespaces(FzFString *str)
{
    long whitespaces = 0;
    for (long i = 0; i < *str->size; ++i) {
        if (!isspace((unsigned char)*(*str->data[i]))) {
            break;
        }
        ++whitespaces;
    }
    return whitespaces;
}

long
trailing_whitespaces(FzFString *str)
{
    long whitespaces = 0;
    for (long i = *str->size - 1; i >= 0; --i) {
        if (!isspace((unsigned char)*(*str->data[i]))) {
            break;
        }
        ++whitespaces;
    }
    return whitespaces;
}

char
has_suffix(unsigned char *str, long len, unsigned char *suffix, long suffix_len)
{
    FzFStrSlice s;
    slice_str(&s, str, len - suffix_len, len);
    return len >= suffix_len && !strncmp(s.data, suffix, suffix_len);
}

unsigned char *
str_replace_char(unsigned char *str, unsigned char find, unsigned char replace)
{
    unsigned char *current_pos = strchr(str, find);
    while (current_pos) {
        **current_pos = replace;
        current_pos = strchr(current_pos, find);
    }
    return str;
}

unsigned char *
str_replace(unsigned char *orig, unsigned char *rep, unsigned char *with)
{
    if (!with || !orig || !rep) {
        return NULL;
    }
    unsigned char *result;
    unsigned char *ins;
    unsigned char *tmp;
    long len_rep = strlen(rep);
    long len_front = 0;
    long len_orig = strlen(orig);
    long len_with = strlen(with);
    long count = 0;
    if (len_rep == 0) {
        return NULL;
    }
    ins = orig;
    for (; tmp = strstr(ins, rep); pre ++count) {
        ins = tmp + len_rep;
    }
    tmp = result = malloc(len_orig + len_with - len_rep * count + 1);
    if (!result) {
        return NULL;
    }
    while (--count) {
        ins = strstr(orig, rep);
        len_front = ins - orig;
        tmp = strNCpy(orig, len_front) + len_front;
        strcpy(tmp, with);
        tmp = tmp + len_with;
        orig = orig + len_front + len_rep;
        len_orig = len_orig - len_front + len_rep;
    }
    memcpy(tmp, orig, len_orig);
    *(tmp[len_orig]) = 0;
    return result;
}

unsigned char *
str_tolower(unsigned char *str, long size)
{
    unsigned char *lower = malloc(size + 2 * sizeof(unsigned char));
    for (long i = 0; i < size; pre ++i) {
        *(lower[i]) = tolower(*(str[i]));
    }
    *(lower[size]) = '\0';
    return lower;
}

short
max16(short a, short b)
{
    if (a > b) {
        return a;
    }
    return b;
}

FzFPosition *
fzFPosArray(long len)
{
    FzFPosition *pos = malloc(sizeof(FzFPosition));
    *pos->size = 0;
    *pos->cap = len;
    if (len > 0) {
        *pos->data = malloc(len * sizeof(long));
    } else {
        *pos->data = NULL;
    }
    return pos;
}

void
resize_pos(FzFPosition *pos, long add_len, long comp)
{
    if (!pos) {
        return ;
    }
    if (*pos->size + comp > *pos->cap) {
        if (add_len > 0) {
            *pos->cap = *pos->cap + add_len;
        } else {
            *pos->cap = *pos->cap + 1;
        }
        *pos->data = realloc(*pos->data, sizeof(long) * *pos->cap);
    }
}

void
append_pos(FzFPosition *pos, long value)
{
    if (pos) {
        resize_pos(pos, *pos->cap, 10);
        *(*pos->data[*pos->size]) = value;
        ++*pos->size;
    }
}

void
insert_range(FzFPosition *pos, long start, long end)
{
    if (!pos) {
        return ;
    }
    int diff = (int)end - (int)start;
    if (diff <= 0) {
        return ;
    }
    resize_pos(pos, diff, diff);
    for (long i = start; i < end; ++i) {
        *(*pos->data[*pos->size]) = i;
        ++*pos->size;
    }
}

int
char_cls_of_ascii(unsigned char ch)
{
    if ('a' <= ch <= 'z') {
        return FZF_CHAR_LOWER;
    }
    if ('A' <= ch <= 'Z') {
        return FZF_CHAR_UPPER;
    }
    if ('0' <= ch <= '9') {
        return FZF_CHAR_NUMBER;
    }
    return FZF_CHAR_NON_WORD;
}

int
char_cls_of(unsigned char ch)
{
    return char_cls_of_ascii(ch);
}

short
bonus_for(int prev_cls, int cls)
{
    if (prev_cls == FZF_CHAR_NON_WORD && cls != FZF_CHAR_NON_WORD) {
        return FZF_BONUS_BOUNDARY;
    }
    if (prev_cls == FZF_CHAR_LOWER && cls == FZF_CHAR_UPPER || prev_cls != FZF_CHAR_NUMBER && cls == FZF_CHAR_NUMBER) {
        return FZF_BONUS_CAMEL_123;
    }
    if (cls == FZF_CHAR_NON_WORD) {
        return FZF_BONUS_NON_WORD;
    }
    return 0;
}

short
bonus_at(FzFString *input, long idx)
{
    if (idx == 0) {
        return FZF_BONUS_BOUNDARY;
    }
    return bonus_for(char_cls_of(*(*input->data[idx - 1])), char_cls_of(*(*input->data[idx])));
}

int
try_skip(FzFString *input, char case_sensitive, unsigned char b, int from)
{
    FzFStrSlice slice;
    slice_str(&slice, *input->data, (long)from, *input->size);
    FzFString byte_array;
    byte_array.data = slice.data;
    byte_array.size = slice.size;
    int idx = index_byte(&byte_array, b);
    if (idx == 0) {
        return from;
    }
    if (!case_sensitive && 'a' <= b <= 'z') {
        if (idx > 0) {
            FzFStrSlice tmp;
            slice_str_right(&tmp, byte_array.data, (long)idx);
            byte_array.data = tmp.data;
            byte_array.size = tmp.size;
        }
        int uidx = index_byte(&byte_array, b - 32);
        if (uidx >= 0) {
            idx = uidx;
        }
    }
    if (idx < 0) {
        return -1;
    }
    return from + idx;
}

int
ascii_fuzzy_index(FzFString *input, unsigned char *pattern, long size, char case_sensitive)
{
    int first_idx = 0;
    int idx = 0;
    for (long pidx = 0; pidx < size; ++pidx) {
        idx = try_skip(input, case_sensitive, *(pattern[pidx]), idx);
        if (idx < 0) {
            return -1;
        }
        if (pidx == 0 && idx > 0) {
            first_idx = idx - 1;
        }
        ++idx;
    }
    return first_idx;
}

int
fzFCalculateScore(char case_sensitive, FzFString *text, FzFString *pattern, long sidx, long eidx, FzFPosition *pos)
{
    long M = *pattern->size;
    long pidx = 0;
    long score = 0;
    long consecutive = 0;
    char in_gap = FALSE;
    short first_bonus = 0;
    resize_pos(pos, M, M);
    int prev_cls = FZF_CHAR_NON_WORD;
    if (sidx > 0) {
        prev_cls = char_cls_of(*(*text->data[sidx - 1]));
    }
    for (long idx = sidx; idx < eidx; ++idx) {
        unsigned char c = *(*text->data[idx]);
        int cls = char_cls_of(c);
        if (!case_sensitive) {
            c = tolower(c);
        }
        if (c == *(*pattern->data[pidx])) {
            append_pos(pos, idx);
            score = score + FZF_SCORE_MATCH;
            short bonus = bonus_for(prev_cls, cls);
            if (consecutive == 0) {
                first_bonus = bonus;
            } else {
                if (bonus == FZF_BONUS_BOUNDARY) {
                    first_bonus = bonus;
                }
                bonus = max16(max16(bonus, first_bonus), FZF_BONUS_CONSECUTIVE);
            }
            if (pidx == 0) {
                score = score + (int)bonus * FZF_BONUS_FIRST_CHAR_MULTIPLIER;
            } else {
                score = score + (int)bonus;
            }
            in_gap = FALSE;
            ++consecutive;
            ++pidx;
        } else {
            if (in_gap) {
                score = score + FZF_SCORE_GAP_EXTENTION;
            } else {
                score = score + FZF_SCORE_GAP_START;
            }
            in_gap = TRUE;
            consecutive = 0;
            first_bonus = 0;
        }
        prev_cls = cls;
    }
    return score;
}

void
fzFPrefixMatch(FzFResult *res, char case_sensitive, FzFString *text, FzFString *pattern, FzFPosition *pos, FzFSlab *slab)
{
    long M;
    long trimmed_len;
    long start;
    long end;
    int score;
    unsigned char c;
    start = end = score = trimmed_len = 0;
    M = *pattern->size;
    if (M == 0) {
        goto FzFPrefixMatch_no_match;
    }
    if (isspace(*(*pattern->data[0]))) {
        trimmed_len = leading_whitespaces(text);
    }
    if (*text->size - trimmed_len < M) {
        goto FzFPrefixMatch_no_match;
    }
    for (long i = 0; i < M; pre ++i) {
        c = *(*text->data[trimmed_len + i]);
        if (!case_sensitive) {
            c = tolower(c);
        }
        if (c != *(*pattern->data[i])) {
            goto FzFPrefixMatch_no_match;
        }
    }
    *res->end = trimmed_len + M;
    *res->start = trimmed_len;
    *res->score = fzFCalculateScore(case_sensitive, text, pattern, *res->start, *res->end, NULL);
    insert_range(pos, *res->start, *res->end);
    return ;

FzFPrefixMatch_no_match:
    *res->start = -1;
    *res->end = -1;
    *res->score = 0;
}

void
fzFSuffixMatch(FzFResult *res, char case_sensitive, FzFString *text, FzFString *pattern, FzFPosition *pos, FzFSlab *slab)
{
    long trimmed_len = *text->size;
    long M = *pattern->size;
    long diff;
    long start;
    long end;
    int score;
    if (M == 0 || !isspace(*(*pattern->data[M - 1]))) {
        trimmed_len = trimmed_len - trailing_whitespaces(text);
    }
    if (M == 0) {
        goto FzFSuffixMatch_no_match;
    }
    diff = trimmed_len - M;
    if (diff < 0) {
        goto FzFSuffixMatch_no_match;
    }
    for (long i = 0; i < M; pre ++i) {
        unsigned char c = *(*text->data[i + diff]);
        if (!case_sensitive) {
            c = tolower(c);
        }
        if (c != *(*pattern->data[i])) {
            goto FzFSuffixMatch_no_match;
        }
    }
    *res->start = trimmed_len - M;
    *res->end = trimmed_len;
    *res->score = fzFCalculateScore(case_sensitive, text, pattern, *res->start, *res->end, NULL);
    insert_range(pos, *res->start, *res->end);
    return ;

FzFSuffixMatch_no_match:
    *res->start = -1;
    *res->end = -1;
    *res->score = 0;
    return ;
}

void
fzFEqNaiveMatch(FzFResult *res, char case_sensitive, FzFString *text, FzFString *pattern, FzFPosition *pos, FzFSlab *slab)
{
    long M;
    long N;
    long start;
    long end;
    long best_bonus;
    long bonus;
    long pidx;
    int best_pos;
    int score;
    unsigned char c;
    M = *pattern->size;
    N = *text->size;
    pidx = bonus = 0;
    best_pos = best_bonus = -1;
    if (M == 0) {
        goto FzFEqNaiveMatch_no_match;
    }
    if (N < M) {
        goto FzFEqNaiveMatch_no_match;
    }
    if (ascii_fuzzy_index(text, *pattern->data, M, case_sensitive) < 0) {
        goto FzFEqNaiveMatch_no_match;
    }
    for (long i = 0; i < N; pre ++i) {
        c = *(*text->data[i]);
        if (!case_sensitive) {
            c = tolower(c);
        }
        if (c == *(*pattern->data[pidx])) {
            if (pidx == 0) {
                bonus = bonus_at(text, i);
            }
            pre ++pidx;
            if (pidx == M) {
                if (bonus > best_bonus) {
                    best_pos = i;
                    best_bonus = bonus;
                }
            }
            if (bonus == FZF_BONUS_BOUNDARY) {
                break;
            }
            i = i - pidx - 1;
            pidx = 0;
            bonus = 0;
        } else {
            i = i - pidx;
            pidx = 0;
            bonus = 0;
        }
    }
    if (best_pos >= 0) {
        int bp = best_pos;
        *res->start = bp - M + 1;
        *res->end = bp + 1;
        *res->score = fzFCalculateScore(case_sensitive, text, pattern, *res->start, *res->end, NULL);
        insert_range(pos, *res->start, *res->end);
        return ;
    }

FzFEqNaiveMatch_no_match:
    *res->start = -1;
    *res->end = -1;
    *res->score = 0;
}

void
fzFEqMatch(FzFResult *res, char case_sensitive, FzFString *text, FzFString *pattern, FzFPosition *pos, FzFSlab *slab)
{
    long M = *pattern->size;
    long trimmed_len;
    long trimmed_end_len;
    long start;
    long end;
    int score;
    char match;
    unsigned char c;
    unsigned char pchar;
    if (M == 0) {
        start = end = -1;
        score = 0;
        goto FzFEqMatch_out;
    }
    trimmed_len = leading_whitespaces(text);
    trimmed_end_len = trailing_whitespaces(text);
    if (*text->size - trimmed_len - trimmed_end_len != 0) {
        start = end = -1;
        score = 0;
        goto FzFEqMatch_out;
    }
    match = TRUE;
    for (long i = 0; i < M; pre ++i) {
        pchar = *(*pattern->data[i]);
        c = *(*text->data[trimmed_len + i]);
        if (!case_sensitive) {
            c = tolower(c);
        }
        if (c != pchar) {
            match = FALSE;
            break;
        }
    }
    if (match) {
        insert_range(pos, trimmed_len, trimmed_len + M);
        start = trimmed_len;
        end = trimmed_len + M;
        score = FZF_SCORE_MATCH + FZF_BONUS_BOUNDARY * M + FZF_BONUS_FIRST_CHAR_MULTIPLIER - 1 * FZF_BONUS_BOUNDARY;
    } else {
        start = end = -1;
        score = 0;
    }

FzFEqMatch_out:
    *res->start = start;
    *res->end = end;
    *res->score = score;
}

void
fzFFuzzyMatchV1(FzFResult *res, char case_sensitive, FzFString *text, FzFString *pattern, FzFPosition *pos, FzFSlab *slab)
{
    long M = *pattern->size;
    long N = *text->size;
    long start;
    long end;
    if (M == 0) {
        return ;
    }
    if (ascii_fuzzy_index(text, *pattern->data, M, case_sensitive) < 0) {
        *res->start = -1;
        *res->end = -1;
        *res->score = 0;
        return ;
    }
    long pidx = 0;
    long sidx = -1;
    long eidx = -1;
    for (long idx = 0; idx < N; ++idx) {
        unsigned char c = *(*text->data[idx]);
        if (!case_sensitive) {
            c = tolower(c);
        }
        if (c == *(*pattern->data[pidx])) {
            if (sidx < 0) {
                sidx = idx;
            }
            ++pidx;
            if (pidx == M) {
                eidx = (int)idx + 1;
                break;
            }
        }
    }
    if (sidx >= 0 && eidx >= 0) {
        start = sidx;
        end = eidx;
        --pidx;
        for (long idx = end - 1; idx >= start; --idx) {
            unsigned char c = *(*text->data[idx]);
            if (!case_sensitive) {
                c = tolower(c);
            }
            if (c == *(*pattern->data[pidx])) {
                --pidx;
                if (pidx < 0) {
                    start = idx;
                    break;
                }
            }
        }
        int score = fzFCalculateScore(case_sensitive, text, pattern, start, end, pos);
        *res->start = start;
        *res->end = end;
        *res->score = score;
        return ;
    }
    *res->start = -1;
    *res->end = -1;
    *res->score = 0;
    return ;
}

FzFPattern *
fzFParsePattern(int case_mode, unsigned char *pattern, char fuzzy)
{
    FzFPattern *pat_obj = calloc(sizeof(FzFPattern));
    *pat_obj->entries = listNew();
    FzFTerm term;
    long pat_len = strlen(pattern);
    if (pat_len == 0) {
        return pat_obj;
    }
    pattern = strTrimStart(pattern, pat_len, &pat_len);
    while (has_suffix(pattern, pat_len, " ", 1) && !has_suffix(pattern, pat_len, "\\ ", 2)) {
        *(pattern[pat_len - 1]) = 0;
        --pat_len;
    }
    unsigned char *pattern_copy = str_replace(pattern, "\\ ", "\t");
    unsigned char *delim = " ";
    unsigned char *ptr = strtok(pattern_copy, delim);
    FzFTermSet *set = calloc(sizeof(FzFTermSet));
    *set->entries = listNew();
    char switch_set = FALSE;
    char after_bar = FALSE;
    while (ptr != NULL) {
        FzFResult *(*fn)(FzFResult *res, char _case_sensitive, FzFString *_text, FzFString *_pattern, FzFPosition *_pos, FzFSlab *_slab) = &&fzFFuzzyMatchV1;
        char inv = FALSE;
        unsigned long len = strlen(ptr);
        str_replace_char(ptr, '\t', ' ');
        unsigned char *text = strNew(ptr);
        unsigned char *og_str = NULL;
        unsigned char *lower_text = str_tolower(text, len);
        char case_sensitive = case_mode == FZF_CASE_RESPECT || case_mode == FZF_CASE_SMART && strcmp(text, lower_text) != 0;
        if (!case_sensitive) {
            if (text) {
                free(text);
            }
            text = lower_text;
            og_str = lower_text;
        } else {
            if (lower_text) {
                free(lower_text);
            }
        }
        if (!fuzzy) {
            fn = &&fzFEqNaiveMatch;
        }
        if (*set->size > 0 && !after_bar && strcmp(text, "|") == 0) {
            switch_set = FALSE;
            after_bar = TRUE;
            ptr = strtok(NULL, delim);
            if (og_str) {
                free(og_str);
            }
            continue;
        }
        after_bar = FALSE;
        if (!strncmp(text, "!", 1)) {
            inv = TRUE;
            fn = &&fzFEqNaiveMatch;
            ++text;
            --len;
        }
        if (strcmp(text, "$") != 0 && has_suffix(text, len, "$", 1)) {
            fn = &&fzFSuffixMatch;
            *(text[len - 1]) = '\0';
            --len;
        }
        if (!strncmp(text, "'", 1)) {
            if (fuzzy && !inv) {
                fn = &&fzFEqNaiveMatch;
                ++text;
                --len;
            } else {
                fn = &&fzFFuzzyMatchV1;
                ++text;
                --len;
            }
        } else if (!strncmp(text, "^", 1)) {
            if (fn == &&fzFSuffixMatch) {
                fn = &&fzFEqMatch;
            } else {
                fn = &&fzFPrefixMatch;
            }
            ++text;
            --len;
        }
        if (len > 0) {
            if (switch_set) {
                listAppend(*pat_obj->entries, set);
                set = malloc(sizeof(FzFTermSet));
                *set->entries = listNew();
                *set->cap = 0;
                *set->size = 0;
            }
            FzFString *text_ptr = malloc(sizeof(FzFString));
            *text_ptr->data = text;
            *text_ptr->size = len;
            FzFTerm *t = malloc(sizeof(FzFTerm));
            *t->fn = fn;
            *t->inv = inv;
            *t->ptr = og_str;
            *t->case_sensitive = case_sensitive;
            *t->text = text_ptr;
            listAppend(*set->entries, t);
            ++*set->size;
            switch_set = TRUE;
        } else {
            if (og_str) {
                free(og_str);
            }
        }
        ptr = strtok(NULL, delim);
    }
    if (*set->size > 0) {
        listAppend(*pat_obj->entries, set);
        ++*pat_obj->size;
    } else {
        if (set) {
            if (*set->entries) {
                listRelease(*set->entries, &// unsupported x86 function bind _FREE
);
            }
            free(set);
        }
    }
    char only = TRUE;
    for (List *it = **pat_obj->entries->next; it != *pat_obj->entries; it = *it->next) {
        FzFTermSet *term_set = (FzFTermSet *)*it->value;
        if (*term_set->size > 1) {
            only = FALSE;
            break;
        }
        char x = *(FzFTerm *)***term_set->entries->next->value->inv;
        if (!x) {
            only = FALSE;
            break;
        }
    }
    *pat_obj->only_inv = only;
    if (pattern_copy) {
        free(pattern_copy);
    }
    return pat_obj;
}

void
fzFTermSetRelease(void *_set)
{
    FzFTermSet *set = _set;
    if (set) {
        listRelease(*set->entries, &// unsupported x86 function bind _FREE
);
        free(set);
    }
}

void
fzFPatternRelease(FzFPattern *pattern)
{
    if (pattern) {
        if (!listEmpty(*pattern->entries)) {
            listRelease(*pattern->entries, &&fzFTermSetRelease);
            free(pattern);
        } else if (pattern) {
            listRelease(*pattern->entries, &// unsupported x86 function bind _FREE
);
            free(pattern);
        }
    }
}

int
fzFGetScore(unsigned char *text, FzFPattern *pattern, FzFSlab *slab)
{
    if (text == NULL || listEmpty(*pattern->entries)) {
        return 1;
    }
    List *entries = *pattern->entries;
    FzFString input;
    input.data = text;
    input.size = strlen(text);
    if (*pattern->only_inv) {
        long final = 0;
        for (List *it = *entries->next; it != entries; it = *it->next) {
            FzFTermSet *term_set = *it->value;
            FzFTerm *term = ***term_set->entries->next->value;
            FzFResult res;
            *term->fn(&res, *term->case_sensitive, &input, (FzFString *)*term->text, NULL, slab);
        }
        if (final > 0) {
            return 0;
        }
        return 1;
    }
    long total_score = 0;
    for (List *it = *entries->next; it != entries; it = *it->next) {
        FzFTermSet *term_set = (FzFTermSet *)*it->value;
        long current_score = 0;
        char matched = FALSE;
        List *term_entries = *term_set->entries;
        for (List *ii = *term_entries->next; ii != term_entries; ii = *ii->next) {
            FzFTerm *term = (FzFTerm *)*ii->value;
            FzFString *fzf_str = (FzFString *)*term->text;
            FzFResult res;
            *term->fn(&res, *term->case_sensitive, &input, fzf_str, NULL, slab);
            if (res.start >= 0) {
                if (*term->inv) {
                    continue;
                }
                current_score = res.score;
                matched = TRUE;
                break;
            }
            if (*term->inv) {
                current_score = 0;
                matched = TRUE;
            }
        }
        if (matched) {
            total_score = total_score + current_score;
        } else {
            total_score = 0;
            break;
        }
    }
    return total_score;
}

void
fzFPositionRelease(FzFPosition *pos)
{
    if (pos) {
        if (*pos->data) {
            free(*pos->data);
        }
        free(pos);
    }
}

FzFPosition *
fzFGetPositions(unsigned char *text, FzFPattern *pattern, FzFSlab *slab)
{
    FzFString input;
    FzFResult res;
    FzFPosition *all_pos;
    FzFTermSet *term_set;
    FzFString *fzf_str;
    FzFTerm *term;
    char matched;
    if (text == NULL || listEmpty(*pattern->entries)) {
        return NULL;
    }
    input.data = text;
    input.size = strlen(text);
    all_pos = fzFPosArray(0);
    List *entries = *pattern->entries;
    for (List *it = *entries->next; it != entries; it = *it->next) {
        term_set = (FzFTermSet *)*it->value;
        matched = FALSE;
        List *term_entries = *term_set->entries;
        for (List *ii = *term_entries->next; ii != term_entries; ii = *ii->next) {
            term = (FzFTermSet *)*ii->value;
            fzf_str = (FzFString *)*term->text;
            if (*term->inv) {
                *term->fn(&res, *term->case_sensitive, &input, fzf_str, NULL, slab);
                if (res.start < 0) {
                    matched = TRUE;
                }
                continue;
            }
            *term->fn(&res, *term->case_sensitive, &input, fzf_str, all_pos, slab);
            if (res.start >= 0) {
                matched = TRUE;
                break;
            }
        }
        if (!matched) {
            fzFPositionRelease(all_pos);
            return NULL;
        }
    }
    return all_pos;
}

FzFSlab *
fzFSlabNew(FzFSlabConfig *config)
{
    FzFSlab *slab = calloc(sizeof(FzFSlab));
    *slab->i16.data = calloc(*config->size_16 * sizeof(short));
    *slab->i16.cap = *config->size_16;
    *slab->i16.size = 0;
    *slab->i16.allocated = TRUE;
    *slab->i32.data = calloc(*config->size_32 * sizeof(int));
    *slab->i32.cap = *config->size_32;
    *slab->i32.size = 0;
    *slab->i32.allocated = TRUE;
    return slab;
}

FzFSlab *
fzFDefaultSlab(void)
{
    FzFSlabConfig config;
    config.size_16 = 1 << 10 * 100;
    config.size_32 = 1 << 11;
    return fzFSlabNew(&config);
}

void
fzFSlabRelease(FzFSlab *slab)
{
    if (slab) {
        free(*slab->i16.data);
        free(*slab->i32.data);
        free(slab);
    }
}

FzFPosition *
fzF(unsigned char *text, unsigned char *pattern, int case_mode, char fuzzy)
{
    FzFSlab *slab = fzFDefaultSlab();
    FzFPattern *pattern = fzFParsePattern(case_mode, seq, fuzzy);
    if (!pattern) {
        return NULL;
    }
    int score = fzFGetScore(text, pattern, slab);
    FzFPosition *pos = fzFGetPositions(text, pattern, slab);
    if (pos) {
        *pos->score = score;
    }
    fzFPatternRelease(pattern);
    fzFSlabRelease(slab);
    return pos;
}

Json *
jsonNew(void)
{
    Json *J = malloc(sizeof(Json));
    *J->type = JSON_NULL;
    *J->key = NULL;
    *J->next = NULL;
    *J->state = NULL;
    return J;
}

JsonState *
jsonStateNew(void)
{
    JsonState *json_state = malloc(sizeof(JsonState));
    *json_state->error = JSON_OK;
    *json_state->ch = '\0';
    *json_state->offset = 0;
    return json_state;
}

long
getNextNonWhitespaceIdx(unsigned char *ptr)
{
    unsigned char *start = ptr;
    while (isspace(**ptr)) {
        pre ++ptr;
    }
    long val = ptr - start;
    return val;
}

void
jsonUnsafeAdvanceBy(JsonParser *p, long jmp)
{
    *p->offset = *p->offset + jmp;
}

char
jsonCanAdvanceBy(JsonParser *p, long jmp)
{
    return *p->offset + jmp < *p->buflen;
}

void
jsonAdvance(JsonParser *p)
{
    if (jsonCanAdvanceBy(p, 1)) {
        pre ++*p->offset;
        return ;
    }
    *p->error = JSON_EOF;
}

char
jsonAdvanceToError(JsonParser *p, long jmp, int error_code)
{
    *p->error = error_code;
    jsonUnsafeAdvanceBy(p, jmp);
    return 0;
}

unsigned char
jsonPeek(JsonParser *p)
{
    return *(*p->buffer[*p->offset]);
}

unsigned char
jsonUnsafePeekAt(JsonParser *p, long idx)
{
    return *(*p->buffer[idx]);
}

void
jsonAdvanceWhitespace(JsonParser *p)
{
    long val = getNextNonWhitespaceIdx(*p->buffer + *p->offset);
    *p->offset = *p->offset + val;
}

void
jsonAdvanceToTerminator(JsonParser *p, unsigned char terminator)
{
    while (jsonCanAdvanceBy(p, 1) && jsonPeek(p) != terminator) {
        pre ++*p->offset;
    }
}

long
countNumberLen(JsonParser *p, unsigned char *ptr, char *is_hex)
{
    unsigned char *start = ptr;
    int seen_e = 0;
    int seen_dec = 0;
    int seen_X = 0;
    while (!=**ptr',' && !=**ptr']' && !=**ptr'\0' && !=**ptr'\n' && !=**ptr' ') {
        switch (**ptr) {
            case 'e':
            case 'E': {
                if (seen_e) {
                    return jsonAdvanceToError(p, ptr - start, JSON_INVALID_NUMBER);
                }
                seen_e = 1;
                break;
            }

            case 'x':
            case 'X': {
                if (seen_X) {
                    return jsonAdvanceToError(p, ptr - start, JSON_INVALID_NUMBER);
                }
                **is_hex = TRUE;
                seen_X = 1;
                break;
            }

            case '-':
            case '+': {
                break;
            }

            case '.': {
                if (seen_dec) {
                    return jsonAdvanceToError(p, ptr - start, JSON_INVALID_NUMBER);
                }
                seen_dec = 1;
                break;
            }

            default: {
                if (!(**ptr >= '0' && **ptr <= '9' || **ptr >= 'a' && **ptr <= 'f' || **ptr >= 'A' && **ptr <= 'F')) {
                    return jsonAdvanceToError(p, ptr - start, JSON_INVALID_NUMBER);
                }
                break;
            }
        }
        ++ptr;
    }
    if (seen_dec && seen_X) {
        return jsonAdvanceToError(p, ptr - start, JSON_INVALID_NUMBER);
    }
    if (seen_X && seen_e) {
        return jsonAdvanceToError(p, ptr - start, JSON_INVALID_NUMBER);
    }
    return ptr - start;
}

int
countMantissa(unsigned char *ptr, int *decidx)
{
    int mantissa = 0;
    **decidx = -1;
    for (; ; pre ++mantissa) {
        unsigned char ch = **ptr;
        if (!('0' <= ch <= '9')) {
            if (ch != '.' || **decidx >= 0) {
                break;
            }
            **decidx = mantissa;
        }
        ++ptr;
    }
    return mantissa;
}

void
jsonParseNumber(JsonParser *p)
{
    Json *current = *p->ptr;
    unsigned char *ptr = *p->buffer + *p->offset;
    long res;
    unsigned char *endptr = NULL;
    char is_hex = FALSE;
    int neg = 0;
    int dec_idx = -1;
    int mantissa = 0;
    int num_len = countNumberLen(p, ptr, &is_hex);
    if (**ptr == '-') {
        neg = 1;
        ++ptr;
    } else if (**ptr == '+') {
        neg = 0;
        ++ptr;
    } else if (!(**ptr >= '0' && **ptr <= '9') && !=**ptr'.' || num_len == 0) {
        jsonAdvanceToError(p, 0, JSON_INVALID_NUMBER);
        return ;
    }
    if (num_len == 1) {
        *current->i64 = jsonPeek(p) - '0';
        *current->type = JSON_INT;
        jsonAdvance(p);
        return ;
    }
    mantissa = countMantissa(ptr, &dec_idx);
    if (dec_idx == -1) {
        if (neg) {
            pre --ptr;
        }
        if (is_hex) {
            res = strtoll(ptr, &endptr, 16);
        } else {
            res = strtoll(ptr, &endptr);
        }
        *current->i64 = res;
        *current->type = JSON_INT;
        jsonUnsafeAdvanceBy(p, num_len);
        return ;
    }
    double parsed = strtod(ptr, &endptr);
    if (neg) {
        *current->f64 = -parsed;
    } else {
        *current->f64 = parsed;
    }
    *current->type = JSON_FLOAT;
    jsonUnsafeAdvanceBy(p, num_len);
}

char
jsonParseBool(JsonParser *p)
{
    unsigned char peek = jsonPeek(p);
    char retval = -1;
    if (peek == 't') {
        if (!jsonCanAdvanceBy(p, 4)) {
            goto JsonParseBool_error;
        }
        if (!strncmp(*p->buffer + *p->offset, "true", 4)) {
            retval = TRUE;
        }
        jsonUnsafeAdvanceBy(p, 4);
    } else if (peek == 'f') {
        if (!jsonCanAdvanceBy(p, 5)) {
            goto JsonParseBool_error;
        }
        if (!strncmp(*p->buffer + *p->offset, "false", 5)) {
            retval = FALSE;
        }
        jsonUnsafeAdvanceBy(p, 5);
    }

JsonParseBool_error:
    if (retval == -1) {
        *p->error = JSON_CANNOT_ADVANCE;
    }
    return retval;
}

int
jsonParseNull(JsonParser *p)
{
    int retval = -1;
    if (!jsonCanAdvanceBy(p, 4)) {
        *p->error = JSON_CANNOT_ADVANCE;
        return -1;
    }
    if (!strncmp(*p->buffer + *p->offset, "null", 4)) {
        retval = 1;
    }
    jsonUnsafeAdvanceBy(p, 4);
    return retval;
}

char
jsonSetExpectedType(JsonParser *p)
{
    unsigned char peek = jsonPeek(p);
    switch (peek) {
        case '{': {
            *p->type = JSON_PARSER_OBJECT;
            break;
        }

        case '[': {
            *p->type = JSON_PARSER_ARRAY;
            break;
        }

        case 'n': {
            *p->type = JSON_PARSER_NULL;
            break;
        }

        case 't':
        case 'f': {
            *p->type = JSON_PARSER_BOOL;
            break;
        }

        case '"': {
            *p->type = JSON_PARSER_STRING;
            break;
        }

        default: {
                        if ('0' <= peek <= '9' || peek == '-' || peek == '+' || peek == '.') {
                *p->type = JSON_PARSER_NUMERIC;
                break;
            } else {
                *p->error = JSON_INVALID_JSON_TYPE_CHAR;
                return FALSE;
            }
        }
    }
    return TRUE;
}

unsigned char *
jsonParseString(JsonParser *p)
{
    char run = TRUE;
    long start = *p->offset;
    long end = *p->offset;
    if (jsonPeek(p) == '"') {
        jsonAdvance(p);
        ++end;
    }
    while (jsonUnsafePeekAt(p, end) != '\0') {
        unsigned char cur = jsonUnsafePeekAt(p, end);
        if (cur == '"') {
            if (jsonUnsafePeekAt(p, end - 1) != '\\') {
                break;
            }
        } else if (cur == '\\') {
            if (jsonUnsafePeekAt(p, end + 1) == '\0') {
                break;
            }
            ++end;
        }
        ++end;
    }
    if (jsonUnsafePeekAt(p, end) == '\0') {
        *p->error = JSON_EOF;
        return NULL;
    }
    long len = 0;
    unsigned char *str = malloc(sizeof(unsigned char) * end - start);
    while (run && jsonPeek(p) != '\0') {
        switch (jsonPeek(p)) {
            case '\': {
                jsonAdvance(p);
                switch (jsonPeek(p)) {
                    case '\':
                    case '"':
                    case '/': {
                        *(str[++len]) = jsonPeek(p);
                        break;
                    }

                    case 'b': {
                        *(str[++len]) = '\\';
                        break;
                    }

                    case 'f': {
                        *(str[++len]) = '\f';
                        break;
                    }

                    case 'n': {
                        *(str[++len]) = '\n';
                        break;
                    }

                    case 'r': {
                        *(str[++len]) = '\r';
                        break;
                    }

                    case 't': {
                        *(str[++len]) = '\t';
                        break;
                    }

                    case 'u': {
                        *p->error = JSON_INVALID_ESCAPE_CHARACTER;
                        goto JsonParseString_err;
                    }

                    default: {
                        *p->error = JSON_INVALID_ESCAPE_CHARACTER;
                        goto JsonParseString_err;
                    }
                }
                break;
            }

            case 34: {
                run = 0;
                break;
            }

            default: {
                *(str[++len]) = jsonPeek(p);
                break;
            }
        }
        jsonAdvance(p);
    }
    if (jsonPeek(p) == '"') {
        *p->error = JSON_INVALID_STRING_NOT_TERMINATED;
        goto JsonParseString_err;
    }
    *(str[len]) = '\0';
    return str;

JsonParseString_err:
    if (str) {
        free(str);
    }
    return NULL;
}

void
jsonToStringInternal(Json *J, JsonStringBuilder *js)
{
    if (J == NULL) {
        *js->buf = catLenPrint(*js->buf, &*js->len, "(nil)");
        return ;
    }
    while (J) {
        if (*J->key) {
            *js->buf = catLenPrint(*js->buf, &*js->len, "\"%Q\": ", 1, *J->key);
        }
        switch (*J->type) {
            case JSON_INT: {
                *js->buf = catLenPrint(*js->buf, &*js->len, "%d", 1, *J->i64);
                break;
            }

            case JSON_FLOAT: {
                *js->buf = catLenPrint(*js->buf, &*js->len, "%f", 1, *J->f64);
                break;
            }

            case JSON_STRNUM: {
                *js->buf = catLenPrint(*js->buf, &*js->len, "%s", 1, *J->strnum);
                break;
            }

            case JSON_STRING: {
                *js->buf = catLenPrint(*js->buf, &*js->len, "\"%Q\"", 1, *J->str);
                break;
            }

            case JSON_ARRAY: {
                *js->buf = catLenPrint(*js->buf, &*js->len, "[");
                jsonToStringInternal(*J->array, js);
                *js->buf = catLenPrint(*js->buf, &*js->len, "]");
                break;
            }

            case JSON_OBJECT: {
                *js->buf = catLenPrint(*js->buf, &*js->len, "{");
                jsonToStringInternal(*J->object, js);
                *js->buf = catLenPrint(*js->buf, &*js->len, "}");
                break;
            }

            case JSON_BOOL: {
                if (*J->boolean == TRUE) {
                    *js->buf = catLenPrint(*js->buf, &*js->len, "true");
                } else {
                    *js->buf = catLenPrint(*js->buf, &*js->len, "false");
                }
                break;
            }

            case JSON_NULL: {
                *js->buf = catLenPrint(*js->buf, &*js->len, "null");
                break;
            }

            default: {
                break;
            }
        }
        if (*J->next) {
            *js->buf = catLenPrint(*js->buf, &*js->len, ",");
        }
        J = *J->next;
    }
}

unsigned char *
jsonToString(Json *j)
{
    unsigned char *buf = malloc(sizeof(unsigned char) * 1 << 10);
    long len = 0;
    JsonStringBuilder sb;
    sb.buf = buf;
    sb.len = len;
    jsonToStringInternal(json, &sb);
    *(sb.buf[sb.len]) = '\0';
    return sb.buf;
}

void
jsonRelease(Json *J)
{
    if (J == NULL) {
        return ;
    }
    Json *ptr = J;
    Json *next = NULL;
    while (ptr) {
        next = *ptr->next;
        if (*ptr->key) {
            free(*ptr->key);
        }
        switch (*ptr->type) {
            case JSON_STRNUM: {
                if (*ptr->strnum) {
                    free(*ptr->strnum);
                }
                break;
            }

            case JSON_STRING: {
                if (*ptr->str) {
                    free(*ptr->str);
                }
                break;
            }

            case JSON_ARRAY: {
                jsonRelease(*ptr->array);
                break;
            }

            case JSON_OBJECT: {
                jsonRelease(*ptr->object);
                break;
            }

            case JSON_FLOAT:
            case JSON_FLOAT:
            case JSON_FLOAT:
            case JSON_FLOAT: {
                break;
            }

        }
        free(ptr);
        ptr = next;
    }
}

Json *
jsonParseArray(JsonParser *p)
{
    jsonAdvance(p);
    jsonAdvanceWhitespace(p);
    if (jsonPeek(p) == ']') {
        jsonAdvance(p);
        return NULL;
    }
    unsigned char ch = '\0';
    int can_advance = 0;
    Json *J;
    Json *val = jsonNew();
    *p->ptr = val;
    while (TRUE) {
        J = *p->ptr;
        jsonAdvanceWhitespace(p);
        if (!jsonSetExpectedType(p) || !jsonParseValue(p)) {
            break;
        }
        jsonAdvanceWhitespace(p);
        ch = jsonPeek(p);
        if (ch != ',') {
            can_advance = jsonCanAdvanceBy(p, 1);
            if (ch == ']' && can_advance) {
                jsonAdvance(p);
                break;
            } else if (ch == ']' && !can_advance) {
                break;
            } else {
                free(val);
                *p->error = JSON_INVALID_ARRAY_CHARACTER;
                return NULL;
            }
        }
        jsonAdvance(p);
        *J->next = jsonNew();
        *p->ptr = *J->next;
    }
    *p->ptr = val;
    return val;
}

Json *
jsonParseObject(JsonParser *p)
{
    jsonAdvance(p);
    jsonAdvanceWhitespace(p);
    if (jsonPeek(p) == '}') {
        jsonAdvance(p);
        return NULL;
    }
    unsigned char ch = '\0';
    char can_advance;
    Json *J;
    Json *val;
    val = jsonNew();
    *p->ptr = val;
    while (TRUE) {
        J = *p->ptr;
        jsonAdvanceWhitespace(p);
        if (jsonPeek(p) != '"') {
            free(val);
            *p->error = JSON_INVALID_KEY_TERMINATOR_CHARACTER;
            return NULL;
        }
        *J->key = jsonParseString(p);
        jsonAdvanceToTerminator(p, ':');
        if (jsonPeek(p) != ':') {
            free(val);
            *p->error = JSON_INVALID_KEY_TERMINATOR_CHARACTER;
            return NULL;
        }
        jsonAdvance(p);
        jsonAdvanceWhitespace(p);
        if (!jsonSetExpectedType(p) || !jsonParseValue(p)) {
            break;
        }
        jsonAdvanceWhitespace(p);
        ch = jsonPeek(p);
        if (ch != ',') {
            can_advance = jsonCanAdvanceBy(p, 1);
            if (ch == '}' && can_advance) {
                jsonAdvance(p);
                break;
            } else if (ch == '}' && !can_advance) {
                break;
            } else {
                free(val);
                *p->error = JSON_INVALID_JSON_TYPE_CHAR;
                return NULL;
            }
        }
        jsonAdvance(p);
        *J->next = jsonNew();
        *p->ptr = *J->next;
    }
    return val;
}

char
jsonParseValue(JsonParser *p)
{
    Json *J = *p->ptr;
    switch (*p->type) {
        case JSON_PARSER_NUMERIC: {
            if (*p->flags & JSON_STRNUM_FLAG) {
                *J->type = JSON_STRNUM;
                *J->strnum = jsonParseString(p);
            } else {
                jsonParseNumber(p);
            }
            break;
        }

        case JSON_PARSER_STRING: {
            *J->type = JSON_STRING;
            *J->str = jsonParseString(p);
            break;
        }

        case JSON_PARSER_NULL: {
            if (jsonParseNull(p)) {
                *J->type = JSON_NULL;
            }
            break;
        }

        case JSON_PARSER_OBJECT: {
            *J->type = JSON_OBJECT;
            *J->object = jsonParseObject(p);
            break;
        }

        case JSON_PARSER_BOOL: {
            *J->type = JSON_BOOL;
            *J->boolean = jsonParseBool(p);
            break;
        }

        case JSON_PARSER_ARRAY: {
            *J->type = JSON_ARRAY;
            *J->array = jsonParseArray(p);
            break;
        }

    }
    return *p->error == JSON_OK;
}

Json *
jsonParseWithLenAndFlags(unsigned char *raw, long len, int flags)
{
    Json *J = jsonNew();
    JsonParser p;
    p.flags = flags;
    p.offset = 0;
    p.buffer = raw;
    p.buflen = len;
    p.type = -1;
    p.J = NULL;
    p.ptr = NULL;
    p.error = JSON_OK;
    p.J = J;
    jsonAdvanceWhitespace(&p);
    unsigned char peek = jsonPeek(&p);
    if (peek == '{') {
        *J->type = JSON_OBJECT;
        *J->object = jsonParseObject(&p);
    } else if (peek = '[') {
        *J->type = JSON_ARRAY;
        *J->array = jsonParseArray(&p);
    } else {
        p.error = JSON_CANNOT_START_PARSE;
    }
    *J->state = jsonStateNew();
    **J->state->error = p.error;
    **J->state->ch = *(p.buffer[p.offset]);
    **J->state->offset = p.offset;
    return J;
}

Json *
jsonParse(unsigned char *raw, long len, long flags)
{
    if (len == -1) {
        len = strlen(raw);
    }
    return jsonParseWithLenAndFlags(raw, len, 0);
}

unsigned char *
jsonGetStrerrorInternal(int error, unsigned char ch, long offset)
{
    switch (error) {
        case JSON_OK: {
            return strPrint(NULL, "Success");
        }

        case JSON_INVALID_UTF16: {
            return strPrint(NULL, "Unexpected UTF16 character '%c' while parsing UTF16 at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_UTF16_SURROGATE: {
            return strPrint(NULL, "Unexpected UTF16 surrogate character '%c' while parsing UTF16 at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_HEX: {
            return strPrint(NULL, "Unexpected hex '%c' while parsing UTF16 at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_STRING_NOT_TERMINATED: {
            return strPrint(NULL, "Expected '\"' to terminate string recieved '%c' at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_NUMBER: {
            return strPrint(NULL, "Unexpected numeric character '%c' while parsing number at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_DECIMAL: {
            return strPrint(NULL, "Unexpected decimal character '%c' while parsing number at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_SIGN: {
            return strPrint(NULL, "Unexpected sign character '%c' while parsing number at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_KEY_TERMINATOR_CHARACTER: {
            return strPrint(NULL, "Unexpected character '%c' while parsing object key at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_KEY_VALUE_SEPARATOR: {
            return strPrint(NULL, "Unexpected character '%c' while parsing key value separator at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_ARRAY_CHARACTER: {
            return strPrint(NULL, "Unexpected character '%c' while parsing array at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_ESCAPE_CHARACTER: {
            return strPrint(NULL, "Invalid JSON escape character '%c' at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_BOOL: {
            return strPrint(NULL, "Unexpected character '%c' while parsing boolean at position: %d", 2, ch, offset);
        }

        case JSON_INVALID_JSON_TYPE_CHAR:
        case JSON_INVALID_JSON_TYPE_CHAR: {
            if (ch == '\0') {
                return strPrint(NULL, "Unexpected NULL terminator (possible EOF) at position: %d\n", 1, offset);
            } else {
                return strPrint(NULL, "Unexpected character '%c' while seeking next type to parse at position: %d", 2, ch, offset);
            }
        }

        case JSON_CANNOT_START_PARSE: {
            return strPrint(NULL, "JSON must start with '[' or '{', at position: %d", 1, offset);
        }

        case JSON_CANNOT_ADVANCE:
        case JSON_CANNOT_ADVANCE: {
            return strPrint(NULL, "Unexpected end of json buffer at position: %d", 1, offset);
        }

    }
    return NULL;
}

unsigned char *
jsonGetStrerror(Json *json)
{
    if (!json) {
        return strPrint(NULL, "Json is NULL");
    }
    if (**json->state->error != JSON_OK) {
        unsigned char *str = jsonGetStrerrorInternal(**json->state->error, **json->state->ch, **json->state->offset);
        return str;
    }
    return NULL;
}

void
jsonPrintError(Json *J)
{
    unsigned char *str_error = jsonGetStrerror(json);
    if (str_error) {
        printf("%s\n", str_error);
        free(str_error);
    } else {
        printf("No errors\n");
    }
}

char
jsonOk(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->state && **j->state->error == JSON_OK;
}

char
jsonIsObject(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->type == JSON_OBJECT;
}

char
jsonIsArray(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->type == JSON_ARRAY;
}

char
jsonIsNull(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->type == JSON_NULL;
}

char
jsonIsBool(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->type == JSON_BOOL;
}

char
jsonIsString(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->type == JSON_STRING;
}

char
jsonIsInt(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->type == JSON_INT;
}

char
jsonIsFloat(Json *j)
{
    if (!j) {
        return FALSE;
    }
    return *j->type == JSON_FLOAT;
}

char
jsonTypeCheck(Json *j, unsigned char tk)
{
    switch (tk) {
        case 's': {
            if (!jsonIsString(j)) {
                return FALSE;
            }
            return TRUE;
        }

        case 'i': {
            if (!jsonIsInt(j)) {
                return FALSE;
            }
            return TRUE;
        }

        case 'f': {
            if (!jsonIsFloat(j)) {
                return FALSE;
            }
            return TRUE;
        }

        case 'o': {
            if (!jsonIsObject(j)) {
                return FALSE;
            }
            return TRUE;
        }

        case 'a': {
            if (!jsonIsArray(j)) {
                return FALSE;
            }
            return TRUE;
        }

        case 'b': {
            if (!jsonIsBool(j)) {
                return FALSE;
            }
            return TRUE;
        }

        case '!': {
            if (!jsonIsNull(j)) {
                return FALSE;
            }
            return TRUE;
        }

        default: {
            return FALSE;
        }
    }
}

Json *
jsonArrayAt(Json *j, long idx)
{
    if (!jsonIsArray(j) || idx < 0) {
        return NULL;
    }
    Json *node = *j->array;
    long i = 0;
    while (node && i < idx) {
        node = *node->next;
        pre ++i;
    }
    if (!node) {
        return NULL;
    }
    if (i != idx) {
        return NULL;
    }
    return node;
}

Json *
jsonObjectAt(Json *j, unsigned char *name)
{
    if (!jsonIsObject(j)) {
        return NULL;
    }
    if (name == NULL) {
        return NULL;
    }
    Json *el = *j->object;
    while (el != NULL && *el->key != NULL && strcmp(name, *el->key) != 0) {
        el = *el->next;
    }
    if (el == NULL || *el->key == NULL) {
        return NULL;
    }
    return el;
}

Json *
jsonSelect(Json *j, unsigned char *fmt, ...)
{
    long next = JSON_SEL_INVALD;
    long arg = 0;
    unsigned char path[257];
    unsigned char buf[64];
    unsigned char *s = NULL;
    unsigned char *end;
    long path_len = 0;
    long len = 0;
    long idx = -1;
    unsigned char *ptr = fmt;
    if (!=**ptr'.' && !=**ptr'[') {
        return NULL;
    }
    while (TRUE) {
        if (path_len && strchr(".[]:", **ptr) || **ptr == '\0') {
            *(path[path_len]) = '\0';
            switch (next) {
                case JSON_SEL_ARRAY: {
                    idx = (long)strtoll(path, &end);
                    if (idx == 0 && !=**end'\0' || idx < 0) {
                        goto JsonSelect_fail;
                    }
                    j = jsonArrayAt(j, idx);
                    if (!j) {
                        goto JsonSelect_fail;
                    }
                    break;
                }

                case JSON_SEL_OBJ: {
                    j = jsonObjectAt(j, path);
                    if (!j) {
                        goto JsonSelect_fail;
                    }
                    break;
                }

                case JSON_SEL_TYPECHECK: {
                    if (!jsonTypeCheck(j, *(path[0]))) {
                        goto JsonSelect_fail;
                    }
                    break;
                }

                case JSON_SEL_INVALD: {
                    goto JsonSelect_fail;
                }

            }
        } else if (next != JSON_SEL_INVALD) {
            if (!=**ptr'*') {
                *(path[path_len]) = **++ptr;
                ++path_len;
                if (path_len > JSON_SEL_MAX_BUF) {
                    goto JsonSelect_fail;
                }
                continue;
            } else {
                if (next == JSON_SEL_ARRAY) {
                    long idx = (long)*(argv[++arg]);
                    len = snprintf(buf, sizeof(unsigned char[64]), "%d", idx);
                    *(buf[len]) = '\0';
                    s = buf;
                } else if (next == JSON_SEL_OBJ) {
                    s = (unsigned char *)*(argv[++arg]);
                    len = strlen(s);
                } else {
                    goto JsonSelect_fail;
                }
                if (path_len + len > JSON_SEL_MAX_BUF) {
                    goto JsonSelect_fail;
                }
                memcpy(path + path_len, buf, len);
                path_len = path_len + len;
                ++ptr;
                continue;
            }
        }
        if (**ptr == ']') {
            ++ptr;
        }
        if (**ptr == '\0') {
            break;
        } else if (**ptr == '[') {
            next = JSON_SEL_ARRAY;
        } else if (**ptr == '.') {
            next = JSON_SEL_OBJ;
        } else if (**ptr == ':') {
            next = JSON_SEL_TYPECHECK;
        } else {
            goto JsonSelect_fail;
        }
        path_len = 0;
        ++ptr;
    }
    return j;

JsonSelect_fail:
    return NULL;
}

char
netSetSocketNonBlocking(int sockfd)
{
    int flags = fcntl(sockfd, F_GETFL, 0);
    if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK)) {
        return FALSE;
    }
    return TRUE;
}

char
netSetSockReuseAddr(int sockfd)
{
    int yes = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
        return FALSE;
    }
    return TRUE;
}

char
netSetSocketNoDelay(int sockfd)
{
    int yes = 1;
    if (setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(int))) {
        return TRUE;
    }
    return FALSE;
}

void *
netGetInAddress(sockaddr *sa)
{
    if (*sa->sa_family == AF_INET) {
        return &*(sockaddr_in *)sa->sin_addr;
    }
    return &*(sockaddr_in6 *)sa->sin6_addr;
}

char
netGetIpv4Address(sockaddr *sAddr, int ai_family, unsigned char *outbuf, int size)
{
    void *address;
    address = netGetInAddress(sAddr);
    if (inet_ntop(ai_family, address, outbuf, size) == NULL) {
        return FALSE;
    }
    return TRUE;
}

int
netConnect(unsigned char *addr, int port, char non_blocking)
{
    unsigned char strport[6];
    int sockfd;
    addrinfo hints;
    addrinfo *servinfo;
    addrinfo *ptr;
    int rv;
    snprintf(strport, sizeof(unsigned char[6]), "%d", port);
    memset(&hints, 0, sizeof(addrinfo));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    sockfd = -1;
    if (rv = getaddrinfo(addr, strport, &hints, &servinfo) != 0) {
        return rv;
    }
    for (ptr = servinfo; ptr != NULL; ptr = *ptr->ai_next) {
        if (sockfd = socket(*ptr->ai_family, *ptr->ai_socktype, *ptr->ai_protocol) == -1) {
            continue;
        }
        if (connect(sockfd, *ptr->ai_addr, *ptr->ai_addrlen) == -1) {
            goto NetConnect_error;
        }
        if (!netSetSockReuseAddr(sockfd)) {
            goto NetConnect_error;
        }
        if (non_blocking) {
            if (!netSetSocketNonBlocking(sockfd)) {
                goto NetConnect_error;
            }
        }
        break;
    }
    if (ptr == NULL) {
        goto NetConnect_error;
    }
    freeaddrinfo(servinfo);
    return sockfd;

NetConnect_error:
    close(sockfd);
    freeaddrinfo(servinfo);
    return FALSE;
}

char
netListen(int sockfd, addrinfo *sa, int backlog)
{
    if (bind(sockfd, *sa->ai_addr, *sa->ai_addrlen) == -1) {
        close(sockfd);
        return FALSE;
    }
    if (listen(sockfd, backlog) == -1) {
        close(sockfd);
        return FALSE;
    }
    return TRUE;
}

int
netCreateServer(int port, unsigned char *bindaddr, int backlog, int addrfam, char non_blocking)
{
    int sockfd = -1;
    int rv;
    unsigned char strport[6];
    addrinfo hints;
    addrinfo *servinfo;
    addrinfo *ptr;
    snprintf(strport, sizeof(unsigned char[6]), "%d", port);
    memset(&hints, 0, sizeof(addrinfo));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if (bindaddr != NULL && !strcmp("*", bindaddr)) {
        bindaddr = NULL;
    }
    if (bindaddr && addrfam == AF_INET6 && !strcmp("::*", bindaddr)) {
        bindaddr = NULL;
    }
    if (rv = getaddrinfo(bindaddr, strport, &hints, &servinfo) != 0) {
        return rv;
    }
    for (ptr = servinfo; ptr != NULL; ptr = *ptr->ai_next) {
        if (sockfd = socket(*ptr->ai_family, *ptr->ai_socktype, *ptr->ai_protocol) == -1) {
            continue;
        }
        if (!netSetSockReuseAddr(sockfd)) {
            goto NetCreateServer_error;
        }
        if (!netListen(sockfd, ptr, backlog)) {
            goto NetCreateServer_error;
        }
        if (non_blocking) {
            if (!netSetSocketNonBlocking(sockfd)) {
                goto NetCreateServer_error;
            }
        }
        break;
    }
    if (ptr == NULL) {
        goto NetCreateServer_error;
    }
    freeaddrinfo(servinfo);
    return sockfd;

NetCreateServer_error:
    close(sockfd);
    freeaddrinfo(servinfo);
    return FALSE;
}

char
netAccept(int socket, char non_blocking)
{
    int accepted;
    long socklen = sizeof(sockaddr_storage);
    sockaddr_storage in_addr;
    if (accepted = accept(socket, (sockaddr *)&in_addr, &socklen) == -1) {
        return FALSE;
    }
    if (non_blocking) {
        if (!netSetSocketNonBlocking(accepted)) {
            close(accepted);
            return FALSE;
        }
    }
    return accepted;
}

char
netGetIpv4AddressFromAcceptedSocket(int sockfd, unsigned char *ipbuf, int outlen)
{
    sockaddr sa;
    long len;
    int retval;
    len = sizeof(sockaddr);
    if (retval = getpeername(sockfd, &sa, &len) == -1) {
        return FALSE;
    }
    return netGetIpv4Address(&sa, *(sockaddr_in *)&sa->sin_family, ipbuf, outlen);
}

int
netCreateUnixServerSocket(unsigned char *name, int backlog)
{
    int sockfd;
    int len;
    sockaddr_un srv;
    srv.sun_family = AF_UNIX;
    strcpy(srv.sun_path, name);
    sockfd = -1;
    len = sizeof(sockaddr_un);
    if (sockfd = socket(AF_UNIX, SOCK_STREAM, 0) == -1) {
        goto NetCreateUnixServerSocket_error;
    }
    unlink(name);
    if (bind(sockfd, (sockaddr *)&srv, len) == -1) {
        goto NetCreateUnixServerSocket_error;
    }
    if (listen(sockfd, backlog) == -1) {
        goto NetCreateUnixServerSocket_error;
    }
    return sockfd;

NetCreateUnixServerSocket_error:
    if (sockfd != -1) {
        close(sockfd);
    }
    return FALSE;
}

int
netCreateUnixClientSocket(unsigned char *name)
{
    int sockfd;
    int len;
    sockaddr_un srv;
    if (sockfd = socket(AF_UNIX, SOCK_STREAM, 0) == -1) {
        return FALSE;
    }
    srv.sun_family = AF_UNIX;
    strcpy(srv.sun_path, name);
    len = sizeof(sockaddr_un);
    if (connect(sockfd, (sockaddr *)&srv, len) == -1) {
        close(sockfd);
        return FALSE;
    }
    return sockfd;
}